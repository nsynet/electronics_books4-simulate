//----------------------- T6963C.c --------------------------
//  名称: PG12864LCD显示驱动程序(T6963C) (不带字库)
//-----------------------------------------------------------
#define u8 	unsigned char
#define u16	unsigned int
#include "STC15xxx.h"
#include "T6963C.h"
#include <intrins.h>
#include <math.h>
#include <string.h>
//-----------------------------------------------------------
// ASCII字模宽度及高度定义
//-----------------------------------------------------------
#define ASC_CHR_WIDTH		8
#define ASC_CHR_HEIGHT	12
#define HZ_CHR_HEIGHT		12
#define HZ_CHR_WIDTH		12
//-----------------------------------------------------------
// 液晶宽度与高度定义
//-----------------------------------------------------------
const u8 LCD_WIDTH  = 20;   //宽160像素(160/8 = 20个字节)
const u8 LCD_HEIGHT = 128;  //高128像素
//下面的英文,数字,标点符号等字符点阵存放于程序Flash空间中
code u8 ASC_MSK[96 * 12] = {
0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,// < 0x20时
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// ' '
0x00,0x30,0x78,0x78,0x78,0x30,0x30,0x00,0x30,0x30,0x00,0x00,// '!'
0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// '"'
0x00,0x6c,0x6c,0xfe,0x6c,0x6c,0x6c,0xfe,0x6c,0x6c,0x00,0x00,// '#'
0x30,0x30,0x7c,0xc0,0xc0,0x78,0x0c,0x0c,0xf8,0x30,0x30,0x00,// '$'
0x00,0x00,0x00,0xc4,0xcc,0x18,0x30,0x60,0xcc,0x8c,0x00,0x00,// '%'
0x00,0x70,0xd8,0xd8,0x70,0xfa,0xde,0xcc,0xdc,0x76,0x00,0x00,// '&'
0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// '''
0x00,0x0c,0x18,0x30,0x60,0x60,0x60,0x30,0x18,0x0c,0x00,0x00,// '('
0x00,0x60,0x30,0x18,0x0c,0x0c,0x0c,0x18,0x30,0x60,0x00,0x00,// ')'
0x00,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x00,// '*'
0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,// '+'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x60,0x00,// ','
0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,// '-'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x38,0x38,0x00,0x00,// '.'
0x00,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x00,// '/'
0x00,0x7c,0xc6,0xce,0xde,0xd6,0xf6,0xe6,0xc6,0x7c,0x00,0x00,// '0'
0x00,0x10,0x30,0xf0,0x30,0x30,0x30,0x30,0x30,0xfc,0x00,0x00,// '1'
0x00,0x78,0xcc,0xcc,0x0c,0x18,0x30,0x60,0xcc,0xfc,0x00,0x00,// '2'
0x00,0x78,0xcc,0x0c,0x0c,0x38,0x0c,0x0c,0xcc,0x78,0x00,0x00,// '3'
0x00,0x0c,0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x0c,0x1e,0x00,0x00,// '4'
0x00,0xfc,0xc0,0xc0,0xc0,0xf8,0x0c,0x0c,0xcc,0x78,0x00,0x00,// '5'
0x00,0x38,0x60,0xc0,0xc0,0xf8,0xcc,0xcc,0xcc,0x78,0x00,0x00,// '6'
0x00,0xfe,0xc6,0xc6,0x06,0x0c,0x18,0x30,0x30,0x30,0x00,0x00,// '7'
0x00,0x78,0xcc,0xcc,0xec,0x78,0xdc,0xcc,0xcc,0x78,0x00,0x00,// '8'
0x00,0x78,0xcc,0xcc,0xcc,0x7c,0x18,0x18,0x30,0x70,0x00,0x00,// '9'
0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x00,0x00,0x00,// ':'
0x00,0x00,0x00,0x38,0x38,0x00,0x00,0x38,0x38,0x18,0x30,0x00,// ';'
0x00,0x0c,0x18,0x30,0x60,0xc0,0x60,0x30,0x18,0x0c,0x00,0x00,// '<'
0x00,0x00,0x00,0x00,0x7e,0x00,0x7e,0x00,0x00,0x00,0x00,0x00,// '='
0x00,0x60,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,// '>'
0x00,0x78,0xcc,0x0c,0x18,0x30,0x30,0x00,0x30,0x30,0x00,0x00,// '?'
0x00,0x7c,0xc6,0xc6,0xde,0xde,0xde,0xc0,0xc0,0x7c,0x00,0x00,// '@'
0x00,0x30,0x78,0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0x00,0x00,// 'A'
0x00,0xfc,0x66,0x66,0x66,0x7c,0x66,0x66,0x66,0xfc,0x00,0x00,// 'B'
0x00,0x3c,0x66,0xc6,0xc0,0xc0,0xc0,0xc6,0x66,0x3c,0x00,0x00,// 'C'
0x00,0xf8,0x6c,0x66,0x66,0x66,0x66,0x66,0x6c,0xf8,0x00,0x00,// 'D'
0x00,0xfe,0x62,0x60,0x64,0x7c,0x64,0x60,0x62,0xfe,0x00,0x00,// 'E'
0x00,0xfe,0x66,0x62,0x64,0x7c,0x64,0x60,0x60,0xf0,0x00,0x00,// 'F'
0x00,0x3c,0x66,0xc6,0xc0,0xc0,0xce,0xc6,0x66,0x3e,0x00,0x00,// 'G'
0x00,0xcc,0xcc,0xcc,0xcc,0xfc,0xcc,0xcc,0xcc,0xcc,0x00,0x00,// 'H'
0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,// 'I'
0x00,0x1e,0x0c,0x0c,0x0c,0x0c,0xcc,0xcc,0xcc,0x78,0x00,0x00,// 'J'
0x00,0xe6,0x66,0x6c,0x6c,0x78,0x6c,0x6c,0x66,0xe6,0x00,0x00,// 'K'
0x00,0xf0,0x60,0x60,0x60,0x60,0x62,0x66,0x66,0xfe,0x00,0x00,// 'L'
0x00,0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,// 'M'
0x00,0xc6,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0x00,0x00,// 'N'
0x00,0x38,0x6c,0xc6,0xc6,0xc6,0xc6,0xc6,0x6c,0x38,0x00,0x00,// 'O'
0x00,0xfc,0x66,0x66,0x66,0x7c,0x60,0x60,0x60,0xf0,0x00,0x00,// 'P'
0x00,0x38,0x6c,0xc6,0xc6,0xc6,0xce,0xde,0x7c,0x0c,0x1e,0x00,// 'Q'
0x00,0xfc,0x66,0x66,0x66,0x7c,0x6c,0x66,0x66,0xe6,0x00,0x00,// 'R'
0x00,0x78,0xcc,0xcc,0xc0,0x70,0x18,0xcc,0xcc,0x78,0x00,0x00,// 'S'
0x00,0xfc,0xb4,0x30,0x30,0x30,0x30,0x30,0x30,0x78,0x00,0x00,// 'T'
0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,// 'U'
0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00,0x00,// 'V'
0x00,0xc6,0xc6,0xc6,0xc6,0xd6,0xd6,0x6c,0x6c,0x6c,0x00,0x00,// 'W'
0x00,0xcc,0xcc,0xcc,0x78,0x30,0x78,0xcc,0xcc,0xcc,0x00,0x00,// 'X'
0x00,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x30,0x30,0x78,0x00,0x00,// 'Y'
0x00,0xfe,0xce,0x98,0x18,0x30,0x60,0x62,0xc6,0xfe,0x00,0x00,// 'Z'
0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x00,// '['
0x00,0x00,0x80,0xc0,0x60,0x30,0x18,0x0c,0x06,0x02,0x00,0x00,// '\'
0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,0x00,// ']'
0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// '^'
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,// '_'
0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// '`'
0x00,0x00,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0x76,0x00,0x00,// 'a'
0x00,0xe0,0x60,0x60,0x7c,0x66,0x66,0x66,0x66,0xdc,0x00,0x00,// 'b'
0x00,0x00,0x00,0x00,0x78,0xcc,0xc0,0xc0,0xcc,0x78,0x00,0x00,// 'c'
0x00,0x1c,0x0c,0x0c,0x7c,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,// 'd'
0x00,0x00,0x00,0x00,0x78,0xcc,0xfc,0xc0,0xcc,0x78,0x00,0x00,// 'e'
0x00,0x38,0x6c,0x60,0x60,0xf8,0x60,0x60,0x60,0xf0,0x00,0x00,// 'f'
0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0x7c,0x0c,0xcc,0x78,// 'g'
0x00,0xe0,0x60,0x60,0x6c,0x76,0x66,0x66,0x66,0xe6,0x00,0x00,// 'h'
0x00,0x18,0x18,0x00,0x78,0x18,0x18,0x18,0x18,0x7e,0x00,0x00,// 'i'
0x00,0x0c,0x0c,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0xcc,0xcc,0x78,// 'j'
0x00,0xe0,0x60,0x60,0x66,0x6c,0x78,0x6c,0x66,0xe6,0x00,0x00,// 'k'
0x00,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0x00,// 'l'
0x00,0x00,0x00,0x00,0xfc,0xd6,0xd6,0xd6,0xd6,0xc6,0x00,0x00,// 'm'
0x00,0x00,0x00,0x00,0xf8,0xcc,0xcc,0xcc,0xcc,0xcc,0x00,0x00,// 'n'
0x00,0x00,0x00,0x00,0x78,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,// 'o'
0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x7c,0x60,0xf0,// 'p'
0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0x1e,// 'q'
0x00,0x00,0x00,0x00,0xec,0x6e,0x76,0x60,0x60,0xf0,0x00,0x00,// 'r'
0x00,0x00,0x00,0x00,0x78,0xcc,0x60,0x18,0xcc,0x78,0x00,0x00,// 's'
0x00,0x00,0x20,0x60,0xfc,0x60,0x60,0x60,0x6c,0x38,0x00,0x00,// 't'
0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,// 'u'
0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0x78,0x30,0x00,0x00,// 'v'
0x00,0x00,0x00,0x00,0xc6,0xc6,0xd6,0xd6,0x6c,0x6c,0x00,0x00,// 'w'
0x00,0x00,0x00,0x00,0xc6,0x6c,0x38,0x38,0x6c,0xc6,0x00,0x00,// 'x'
0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3c,0x0c,0x18,0xf0,// 'y'
0x00,0x00,0x00,0x00,0xfc,0x8c,0x18,0x60,0xc4,0xfc,0x00,0x00,// 'z'
0x00,0x1c,0x30,0x30,0x60,0xc0,0x60,0x30,0x30,0x1c,0x00,0x00,// '{'
0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00,// '|'
0x00,0xe0,0x30,0x30,0x18,0x0c,0x18,0x30,0x30,0xe0,0x00,0x00,// '}'
0x00,0x73,0xda,0xce,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// '~'
};
//-----------------------------------------------------------------
#define Delay() { _nop_();	_nop_(); }		//短延时宏定义2xNOP
//-----------------------------------------------------------------
// 延时子程序（x=1~255ms,自适应时钟）
//-----------------------------------------------------------------
void delay_ms(u8 x) {
	u16 i;
	do{
		i = MAIN_Fosc / 13000;
		while(--i);
	}while(--x);
}
struct typFNT_GB16 {	//汉字字模数据结构
	u8 inner_CODE[2];		//汉字内码,2字节
	u8 Msk[24];					//汉字点阵
};
//取本例汉字12*12点阵库时,先在Zimo软件中设置字体字号为宋体小五号,
//取点阵前先设置横向取模,字节不倒序,然后输入汉字并按下Ctrl+Enter,
//最后按下取模按钮获取字模.本例各汉字的内码如下:
code struct typFNT_GB16 GB_16[] = { 
"得",0x27,0xC0,0x24,0x40,0x57,0xC0,0x94,0x40,0x27,0xC0,0x60,0x00,
	 0xAF,0xE0,0x20,0x80,0x2F,0xE0,0x24,0x80,0x21,0x80,0x00,0x00,
"分",0x11,0x00,0x11,0x00,0x20,0x80,0x20,0x80,0x40,0x40,0xBF,0xA0,
	 0x08,0x80,0x08,0x80,0x10,0x80,0x20,0x80,0xC7,0x00,0x00,0x00,
"：",0x00,0x00,0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,
	 0x00,0x00,0x0C,0x00,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
"★",0x04,0x00,0x04,0x00,0x0E,0x00,0x0E,0x00,0xFF,0xE0,0x7F,0xC0,
	 0x1F,0x00,0x1F,0x00,0x3B,0x80,0x20,0x80,0x40,0x40,0x00,0x00,
"■",0x00,0x00,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,
	 0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x7F,0xC0,0x00,0x00,0x00,0x00,
"射",0x20,0x40,0x78,0x40,0x48,0x40,0x7F,0xE0,0x48,0x40,0x7A,0x40,
	 0x49,0x40,0xF9,0x40,0x28,0x40,0x48,0x40,0x99,0xC0,0x00,0x00,
"击",0x04,0x00,0x04,0x00,0x7F,0xC0,0x04,0x00,0x04,0x00,0xFF,0xE0,
	 0x04,0x00,0x44,0x40,0x44,0x40,0x44,0x40,0x7F,0xC0,0x00,0x00,
"训",0x44,0x40,0x25,0x40,0x05,0x40,0x05,0x40,0xC5,0x40,0x45,0x40,
	 0x45,0x40,0x45,0x40,0x55,0x40,0x68,0x40,0x10,0x40,0x00,0x00,
"练",0x22,0x00,0x4F,0xE0,0x42,0x00,0x9F,0x80,0xE4,0x80,0x44,0x80,
	 0xAF,0xE0,0xC0,0x80,0x34,0xC0,0xC8,0xA0,0x13,0xA0,0x00,0x00,
"游",0x91,0x00,0x49,0xE0,0x3E,0x00,0x93,0xE0,0x5C,0x40,0x54,0x80,
	 0x55,0xE0,0x94,0x80,0x94,0x80,0xA4,0x80,0x4D,0x80,0x00,0x00,
"戏",0x02,0x80,0xF2,0x40,0x12,0x40,0x13,0xE0,0x9E,0x00,0x52,0x40,
	 0x22,0x80,0x31,0x00,0x49,0x20,0x42,0xA0,0x8C,0x60,0x00,0x00,
"剩",0x7C,0x20,0x10,0xA0,0xFE,0xA0,0x54,0xA0,0xD6,0xA0,0x54,0xA0,
	 0xD6,0xA0,0x38,0xA0,0x54,0xA0,0x92,0x20,0x10,0xE0,0x00,0x00,
"余",0x04,0x00,0x0A,0x00,0x11,0x00,0x20,0x80,0xDF,0x60,0x04,0x00,
	 0x7F,0xC0,0x15,0x00,0x24,0x80,0x44,0x40,0x9C,0x40,0x00,0x00,
"弹",0x04,0x40,0xE2,0x80,0x2F,0xC0,0x29,0x40,0xEF,0xC0,0x89,0x40,
	 0xEF,0xC0,0x21,0x00,0x3F,0xE0,0x21,0x00,0xC1,0x00,0x00,0x00,
"药",0x11,0x00,0xFF,0xE0,0x11,0x00,0x22,0x00,0x4B,0xE0,0x74,0x20,
	 0x22,0x20,0x59,0x20,0x61,0x20,0x18,0x40,0xE1,0xC0,0x00,0x00
};
u8 gCurRow,gCurCol;   // 图形当前行、列存储，行高16点，列宽8点
u16 txthome,grhome;
//-----------------------------------------------------------
// 读取LCD状态(获取液晶状态字节:STA0~STA7)
//-----------------------------------------------------------
u8 Read_LCD_Status() {


}
//-----------------------------------------------------------
// 从LCD RAM读取一字节数据
//-----------------------------------------------------------
u8 Read_Data() {



}
//-----------------------------------------------------------
// 写数据
//-----------------------------------------------------------
void Write_Data(u8 dat) {


}
//-----------------------------------------------------------
// 写命令
//-----------------------------------------------------------
void Write_Command(u8 cmd) {

									//写结束
}
//-----------------------------------------------------------
// 状态位STA1,STA0判断(写指令和读写数据是否准备就绪)
//-----------------------------------------------------------
u8 Status_BIT_01() {
	u8 i;
	for(i = 10; i > 0;i--) {
		//循环10次读取LCD状态标志位中的最低2位(0x03->00000011)
		//当读取的两位标志位均为1时表示LCD可接收命令,可进行数据读/写
		if((Read_LCD_Status() & 0x03) == 0x03) break; 
		delay_ms(2);
	}
	return i; //错误时返回0
}
//-----------------------------------------------------------
// 状态位ST3判断(数据自动写是否准备就绪)
//-----------------------------------------------------------
u8 Status_BIT_3() {
	u8 i;
	for(i = 100; i > 0; i--){
		//循环10次读取LCD状态标志位中的第3位(0x08->00001000)
		//当读取的标志位为1时表示LCD可执行数据自动写
		if((Read_LCD_Status()&0x08) == 0x08) break; 
		delay_ms(2);
	}
	return i; //错误时返回0
}
//-----------------------------------------------------------
// 向LCD写双参数命令
//-----------------------------------------------------------
u8 LCD_Write_Command_P2(u8 cmd,u8 para1,u8 para2) {
	//发送双参数命令时,先发送第1字节参数,后发送第2字节参数,最后发送
	//命令.每次发送时必须等待LCD状态标志位的低两位为1,它们表示LCD可
	//接收命令,可进行数据读/写
	if(Status_BIT_01() == 0) return 1;  Write_Data(para1);
	if(Status_BIT_01() == 0) return 2;  Write_Data(para2);
	if(Status_BIT_01() == 0) return 3;  Write_Command(cmd);
	return 0; //成功时返回0
}
//-----------------------------------------------------------
// 向LCD写单参数命令
//-----------------------------------------------------------
u8 LCD_Write_Command_P1(u8 cmd,u8 para1) {
	//发送单参数命令时,先发送参数字节,后发送命令字节,每次发送时必须等待
	//LCD状态标志位的低两位为1,它们表示LCD可接收命令,可进行数据读/写
	if(Status_BIT_01() == 0) return 1;  Write_Data(para1);
	if(Status_BIT_01() == 0) return 2;  Write_Command(cmd);
	return 0; //成功时返回0
}
//-----------------------------------------------------------
// 向LCD写无参数命令
//-----------------------------------------------------------
u8 LCD_Write_Command(u8 cmd) {
	//发送无参数命令时,直接发送命令字节,每次发送时必须等待LCD状态标志位
	//的低两位为1,它们表示LCD可接收命令,可进行数据读/写
	if(Status_BIT_01() == 0) return 1;  Write_Command(cmd);
	return 0; //成功时返回0
}
//-----------------------------------------------------------
// 向LCD写一字节数据
//-----------------------------------------------------------
u8 LCD_Write_Data(u8 dat) {
	//写字节数据时,必须等待状态标志位的第3位为1,它表示可向LCD执行数据写入
	if(Status_BIT_3() == 0) return 1;  Write_Data(dat);
//	P1 = 0x33; while (1);
	return 0; //成功时返回0
}
//-----------------------------------------------------------
// 设置当前地址
//-----------------------------------------------------------
void Set_LCD_POS(u8 row, u8 col) {
	//根据行/列计算出它在LCD RAM中的地址
	u16 Addr = row * LCD_WIDTH + col;
	//发送双参数命令,设置地址位置,所发的两字节是16位地址Addr的高8位和低8位
	LCD_Write_Command_P2(LCD_ADD_POS,Addr & 0xFF, Addr >> 8);
}
//-----------------------------------------------------------
// 清屏
//-----------------------------------------------------------
void Clear_Screen() {
	u16 i;
	LCD_Write_Command_P2(LCD_ADD_POS,0x00,0x00);//DDRAM地址：0x0000
	LCD_Write_Command(LCD_AUT_WR);  //自动写模式(写操作时地址将自动+/-)
	for(i = 0;i < 0x2000; i++) {   	//8K的LCD DDRAM全部写入0x00
																	//(0x2000 = 8192 = 8K)
		if(Status_BIT_3() == 0) return;	//未就绪时直接返回
		LCD_Write_Data(0x00);					//写字节0x00
	}
	LCD_Write_Command(LCD_AUT_OVR);	//自动写结束
	LCD_Write_Command_P2(LCD_ADD_POS,0x00,0x00); //重置地址为0x0000
}
//-----------------------------------------------------------
// LCD初始化
//-----------------------------------------------------------
void LCD_Initialise() {
	LCD_Write_Command_P2(LCD_TXT_STP,0x00,0x00); 	//设置文本区首地址
	LCD_Write_Command_P2(LCD_TXT_WID,LCD_WIDTH,0x00);//设置文本区宽度
	LCD_Write_Command_P2(LCD_GRH_STP,0x00,0x00);	//图形区首地址
	LCD_Write_Command_P2(LCD_GRH_WID,LCD_WIDTH,0x00);//图形显示区宽度
	LCD_Write_Command(LCD_CUR_SHP | 0x01); 				//光标形状(单底线)
	LCD_Write_Command(LCD_MOD_OR);								//设置方式为"OR"
	LCD_Write_Command(LCD_DIS_SW  | 0x08);				//设置显示模式
}
//-----------------------------------------------------------
// 中/英文字符显示(wb表示是否反白显示)
//-----------------------------------------------------------
void Display_Str_at_xy(u8 x,u8 y,char Buffer[],u8 wb) {
	char c1,c2,cData;
	u8 i = 0,j,k,uLen = strlen(Buffer);		//uLen取得串长
	while(i < uLen) {
		c1 = Buffer[i]; c2 = Buffer[i+1]; 	//从显示缓冲中读取两字节编码
		//设置显示起始位置(>>3用于将像素地址转换为字节地址)
		Set_LCD_POS(y, x >> 3);
		if((c1 & 0x80) == 0x00)	{//英文字符显示(ASCII码字节高位为0)
			if(c1 < 0x20) {	//处理ASCII小于0x20(空格字符)的非显示与打印字符
				switch(c1) {
					case 0x0D:
					case 0x0A: i++; x = 0; 	//处理回车或换行符
									 if(y < 112) y += HZ_CHR_HEIGHT; continue;
					case 0x08: i++;					//处理退格
									 if(y > ASC_CHR_WIDTH) y -= ASC_CHR_WIDTH;
									 cData = 0x00; break;
				}
			}
			//下面处理的是可显示/打印字符(从程序FLASH中读取字符点阵并显示)
			for(j = 0; j < ASC_CHR_HEIGHT; j++) {
				if(c1 >= 0x20) { //本例列出的可显示/打印字符(ASCII >= 0x20)
				//从ASCII字符点阵库ASC_MSK中读取该字符的一字节点阵数据
					cData = ASC_MSK[(c1 - 0x1F) * ASC_CHR_HEIGHT + j];
					if (wb) cData = ~cData;				//反相处理
					Set_LCD_POS( y + j, x >> 3);	//设置显示位置
					if((x & 0x07) == 0) { //显示位置是8的整数倍则直接发送显示
						LCD_Write_Command(LCD_AUT_WR);	//开自动写
						LCD_Write_Data(cData);					//写一字节点阵数据
						LCD_Write_Command(LCD_AUT_OVR);	//关自动写
					}
					//否则调用OutToLCD进行读屏,组合,再回写LCD显示
					else OutToLCD(cData, x, y + j);
				}
				Set_LCD_POS(y + j, x >> 3);					//重设显示位置
			}
			x += ASC_CHR_WIDTH; //行坐标递增一个ASCII字符宽度
			i++; //Buffer缓冲索引递增1(因为每个ASCII字符在串中占一字节)
		}
		//中文字符显示
		else {
			//根据两字节汉字内码在字库中查找汉字
			for(j = 0;j < sizeof(GB_16)/sizeof(GB_16[0]);j++) {
			//两字节汉字内码均匹配时退出查找
				if(	c1 == GB_16[j].inner_CODE[0] &&
						c2 == GB_16[j].inner_CODE[1])  break;
			}
			//从中文点阵库中读取该汉字的所有点阵并显示
			//每个汉字共占用HZ_CHR_HEIGHT行,每行显示两字节(16像素)
			for(k = 0; k < HZ_CHR_HEIGHT; k++) {
				Set_LCD_POS(y + k, x >> 3);//设置显示位置
				//索引j小于汉字总个数时表示汉字在点阵库中存在
				if(j < sizeof(GB_16)/sizeof(GB_16[0]))  {
				//取得字库中第j个汉字的两字节点阵第k行的两字节点阵
					c1 = GB_16[j].Msk[k*2]; c2 = GB_16[j].Msk[k*2+1];
					if (wb) { c1 = ~c1; c2 = ~c2; } //反相处理
				}
				else c1 = c2 = 0x00; //否则将点阵设为全0
				//显示起始位置为8的整数倍则直接发送显示一行中的第1字节点阵
				if((x & 0x07) == 0) {
					LCD_Write_Command(LCD_AUT_WR);	//开自动写
					LCD_Write_Data(c1);							//写一行中的第1字节
					LCD_Write_Command(LCD_AUT_OVR);	//关自动写
				}
				//如果不是8的倍数则调用OutToLCD进行读屏,组合,再回写LCD
				else OutToLCD(c1, x, y + k);
				//如果第2字节的起始位置是8的倍数则直接发送显示第2字节点阵
				if(((x + 2 + HZ_CHR_WIDTH / 2) & 0x07) == 0) {
					LCD_Write_Command(LCD_AUT_WR);	//开自动写
					LCD_Write_Data(c2);							//写一行中的第2字节
					LCD_Write_Command(LCD_AUT_OVR); //关自动写
				}
				//如果不是8的倍数则调用F进行读屏,组合,再回写LCD
				else OutToLCD(c2,x + 2 + HZ_CHR_WIDTH / 2,y + k);
			}
			x += HZ_CHR_WIDTH;	//行坐标递增一个汉字宽度,
			i += 2; //Buffer缓冲索引递增2(因为当前汉字在缓冲中占两字节)
		}
	}
}
//-----------------------------------------------------------
// 输出起点x不是8的倍数时,先读取LCD屏该位置前后的两字节
// 然后将原字节拆分的的两字节与读取的两字节进行"或操作",最后写回LCD
//-----------------------------------------------------------
void OutToLCD(u8 Dat,u8 x,u8 y) {
	u8 dat1,dat2,a,b;
	//x在一字节中的后面的像素数为b,前面的像素数为a,设x = 11,则b = 3,a = 5
	b = x & 0x07; a = 8 - b;
	//设置显示地址(DDRAM地址指针,其中x/8或x>>3将像素坐标x转换为字节坐标)
	Set_LCD_POS(y, x >> 3);
	LCD_Write_Command(LCD_AUT_RD);  //开自动读
	//从LCD读取两字节数据保存到dat1,dat2
	dat1 = Read_Data();  dat2 = Read_Data();
	//将读取的前后两字节分别与待显示字节的前后部分组合
	dat1 = (dat1 & (0xFF<<a)) | (Dat>>b);
	dat2 = (dat2 & (0xFF>>b)) | (Dat<<a);
	LCD_Write_Command(LCD_AUT_OVR); //关自动写
	Set_LCD_POS(y,x >> 3);					//设置显示位置(DDRAM地址指针)
	LCD_Write_Command(LCD_AUT_WR);	//开自动写
	LCD_Write_Data(dat1);						//输出组合后的两字节中的第1字节
	LCD_Write_Data(dat2);						//输出组合后的两字节中的第2字节
	LCD_Write_Command(LCD_AUT_OVR);	//关自动写
}
//-----------------------------------------------------------
// 绘像素点函数
// 参数:点的坐标,模式1/0分别为显示与清除点
//-----------------------------------------------------------
void Pixel(u8 x,u8 y, u8 Mode) {
	u8 start_addr, dat;
	//由像素坐标x得出位操作命令中的后3位(N2~N0)
	start_addr = 7 - ( x & 0x07);
	//将N2~N0附加到LCD位操作命令LCD_BIT_OP的后3位
	dat = LCD_BIT_OP | start_addr;
	//显示像素时将LCD_BIT_OP命令的第N3位设为1
	if (Mode) dat |= 0x08;
	//设置待显示像素所在的DDRAM字节地址(>>3用于将像素地址转换为字节地址)
	Set_LCD_POS(y, x >> 3);
	LCD_Write_Command(LCD_BIT_OP | dat); //写像素点数据
	//或者直接写成: LCD_Write_Command(dat);
}
//-----------------------------------------------------------
// 两数交换
//-----------------------------------------------------------
void Exchange(u8 *a, u8 *b) {u8 t; t=*a; *a=*b; *b=t;}
//-----------------------------------------------------------
// 绘制直线函数
// 参数:起点与终点坐标,模式为显示(1)或清除(0),点阵不超过255*255)
//-----------------------------------------------------------
void Line(u8 x1,u8 y1, u8 x2,u8 y2, u8 Mode) {
	u8 x,y;						//绘点坐标
	float k,b;				//直线斜率与偏移
	if( fabs(y1 - y2) <= fabs( x1 - x2) ) {
		k = (float)(y2 - y1) / (float)(x2 - x1);
		b = y1 - k * x1;
		if( x1 > x2 ) Exchange(&x1, &x2);
		for(x = x1;x <= x2; x++) {
			y = (u8)(k * x + b); Pixel(x, y, Mode); 
		}
	}
	else {
		k = (float)(x2 - x1) / (float)(y2 - y1) ;
		b = x1 - k * y1;
		if( y1 > y2 ) Exchange(&y1, &y2);
		for(y = y1;y <= y2; y++) {
			x = (u8)(k * y + b); Pixel( x , y,Mode ); 
		}
	}
}
//-----------------------------------------------------------
// 绘制图像(图像数据来自于Flash程序ROM空间)[本例未用]
//-----------------------------------------------------------
void Draw_Image(u8 *G_Buffer, u8 Start_Row, u8 Start_Col) {
	u16 i,j,W,H;
	//图像行/列数控制(G_Buffer的前两个字节分别为图像宽度与高度)
	W = G_Buffer[1];
	for (i = 0;i < W;i++) {
		Set_LCD_POS(Start_Row + i,Start_Col);//设置显示起始地址
		LCD_Write_Command(LCD_AUT_WR);		//开自动写
		H = G_Buffer[0];
		for( j = 0; j < H >> 3; j++)			//绘制图像每行像素
			LCD_Write_Data(G_Buffer[ i * ( H >> 3 ) + j + 2 ]);
		LCD_Write_Command(LCD_AUT_OVR);		//关自动写
	}
}
//-----------------------------------------------------------------
// 清屏
//-----------------------------------------------------------------
void Cls() {
	u16 i;
	LCD_Write_Command_P2(LCD_ADD_POS,0,0);
	LCD_Write_Command(LCD_AUT_WR);
	for(i = 0;i < 0x2000; i++) 	{
		Status_BIT_3(); LCD_Write_Data(0x00); 
	}
	LCD_Write_Command(LCD_AUT_OVR); 
	LCD_Write_Command_P2(LCD_ADD_POS,0,0); 
	gCurRow = 0;
	gCurCol = 0;
}