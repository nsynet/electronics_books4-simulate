//-------------------------- 1-Wire.c -----------------------------
//  名称: 1-Wire总线器件ROM搜索及多点DS18B20测温程序
//-----------------------------------------------------------------
#define u8  unsigned char
#define u16 unsigned int
#define s8  signed char
#include "STC15xxx.h"
#include <intrins.h>
#include <string.h>
#include <stdio.h>
#include "1-Wire.h"
u8 Temp_Value[2];				//存放所读取的两字节温度数据
u8 ROMCODE[8];					//ROMCODE(64位)
u8 LCD_Buffer[21];				//液晶显示缓冲
//当前分支层及上次搜索的最低分支层
s8	Level,Last_Level;		//(注意将二者定义为有符号数)
u8	CRC8;						//CRC-8校验变量
bit		bit_A,bit_B, bj;		//读ROMCODE的当前位原码与反码等
extern void LCD_ShowString(u8 r, u8 c,u8 *str);
//-----------------------------------------------------------------
// us延时函数@12MHz
//-----------------------------------------------------------------
void delay1us() {_nop_(); _nop_(); _nop_(); _nop_();}
void delay_us(u16 x) { while (x--) {_nop_();_nop_();_nop_();_nop_();}}
//-----------------------------------------------------------------
// ms延时函数@12MHz(限于1~255)
//-----------------------------------------------------------------
#define MAIN_Fosc 12000000L
void delay_ms(u8 ms) {
	u16 i;
	do{
		i = MAIN_Fosc / 13000; while(--i);
	} while(--ms);
}
//-----------------------------------------------------------------
// 发送读时隙时序
//-----------------------------------------------------------------
void Read_Slot(){


}
//-----------------------------------------------------------------
// 从1-Wire总线读取1位
//-----------------------------------------------------------------
u8 Read_Romcode_bit() {

}
//-----------------------------------------------------------------
// 向1-Wire总线写1字节
//-----------------------------------------------------------------
void Write_Byte(u8 A) {

}
//-----------------------------------------------------------------
// 从1-Wire总线读取1字节
//-----------------------------------------------------------------
u8 Read_Byte() {

}
//-----------------------------------------------------------------
// 向1-Wire总线写1位0/1
//-----------------------------------------------------------------
void Write_DQ_bit(u8 b) {

} 
//-----------------------------------------------------------------
// 1-Wire总线复位
//----------------------------------------------------------------- 
u8 RESET() { 

}
//-----------------------------------------------------------------
// 转换并显示当前找到的器件的8字节(64位)ROMCODE
//-----------------------------------------------------------------
void Show_Romcode(u8 r, u8 c) {

}
//-----------------------------------------------------------------
// 搜索1-Wire总线上一只器件的64位ROMCODE
// 返回0表示搜索到一个ROMCODE,否则表示无器件或搜索的ROMCODE校验错
//-----------------------------------------------------------------
u8 Search_ROM1() {
	u8 i;	
	if (RESET()) return 0;			//复位,无器件在线时返回
	Write_Byte(SERACH_ROM);			//发送ROM搜索命令
	Level = - 1;					//设当前搜索的分支层为-1
	for (i = 0; i < 64; i++) {	//从0位开始索64位ROMCODE
		bit_A = Read_Romcode_bit();	//读取第i位的原码
		bit_B = Read_Romcode_bit();	//读取第i位的反码
		//---------------------------------------------------------11
		//读取的结果为"11"时,搜索结束,程序返回
		if (bit_A == 1 && bit_B == 1) return 1;
		//-----------------------------------------------------10或01
		//读取的结果为"10"或"01"时,表示所有从机的此位均为"0"或"1"
		//将此位保存到8字节共64位的数组ROMCODE中.
		//如果为0表示所有从机此位均为"0",故发送"0"使所有该位为0的从机继续通信
		//如果为1表示所有从机此位均为"1",故发送"1"使所有该位为1的从机继续通信
		else if (bit_A != bit_B) { //两位为01或10
			Save_ROMCODE_Bit_i(ROMCODE,i,(u8)bit_A); 
			Write_DQ_bit(bit_A); 
		}
		//---------------------------------------------------------00
		//读取的结果为"00"时,表示从机中此位同时有"0"与"1",在该层出现搜索分支
		else if (bit_A == 0 && bit_B == 0) {
			//"="=====================================================
			//当前搜索遇到的分支层位置等于前一搜索路径中最低的分支层位置
			if(i == Last_Level) {
				Save_ROMCODE_Bit_i(ROMCODE,i,1);	//设第i位为"1" 
				Write_DQ_bit(1);					//开始搜索"1分支"
			}
			//">"=====================================================
			//当前搜索遇到的分支层低于前一趟搜索的最低分支层
			else if (i > Last_Level) {
				Save_ROMCODE_Bit_i(ROMCODE,i,0);	//设第i位为"0" 
				Write_DQ_bit(0);					//先默认沿"0分支"搜索
				Level = i;							//记录当前分支层
			}
			//"<"=====================================================
			//当前搜索遇到的分支层高于上一次搜索的最低分支层
			//此时的“左右分支选择”决定于上一次ROMCODE搜索结果中的对应位
			else if (i < Last_Level) {
				//读取上一趟搜索到的ROMCODE中的第i位
				bj = Read_ROMCODE_Bit_i(ROMCODE,i); 
				Write_DQ_bit(bj);
				if (bj == 0) Level = i;		//该位为"0"时记录当前分支层
				//bj = 0时发送0搜索"0分支",bj=1时发送1搜索"1分支"
			}
		} //完成1位搜索----------------------------------------------
	} //完成64位搜索-------------------------------------------------
	Last_Level = Level; 		//更新最大分支层
	CRC8 = 0x00; for (i = 0; i < 8; i++) CRC_8(ROMCODE[i]);
	//对8字(64位)ROMCODE执行CRC_8校验,正确时返回0,否则返回1
	return CRC8 == 0x00 ? 0 : 1;
}
//-----------------------------------------------------------------
// 搜索1-Wire上挂载的所有器件的ROMCODE
//-----------------------------------------------------------------
void Search_ALL_ROM() {
	u8 i;	
	int Device_Count = 0;		//初始时搜索到的器件归0
	Last_Level = - 1;			//初始时设最大分支层为-1
	//开始搜索第一个器件之前将64位的ROMCODE清0
	for (i = 0; i < 8; i++) ROMCODE[i] = 0x00;
	//开始搜索所有在线器件的ROMCODE
	while(1) {
		//搜索一个新的ROMCODE,未找到或出错时退出
		if (Search_ROM1()) break;
		//如果为温度传感器则输出温度值
		if (ROMCODE[0] == 0x28) {
			sprintf(LCD_Buffer,
			"Temp: %5.1f\xDF\x43   ",Get_Temperature(ROMCODE));
			LCD_ShowString(3, 0, LCD_Buffer);
		}	//输出*清除温度显示区
		else LCD_ShowString(3,0,"********************");
		//在第1行0列显示当前找到的器件总数
		sprintf(LCD_Buffer,"Found: #%d",++Device_Count);
		LCD_ShowString(1, 0, LCD_Buffer);
		//在第2行0列显示当前器件ROMCODE
		Show_Romcode(2,0);
		//如果完成当前搜索后当前分支层仍为-1则结束查找
		if (Level == -1 ) break;
	}
}
//-----------------------------------------------------------------
// 读取存放于8字节数组A中的ROMCODE的第i位(0/1)
//-----------------------------------------------------------------
u8 Read_ROMCODE_Bit_i(u8 A[],u8 i) {
	//得出64位ROMCODE中第i位所处的字节值,及该位的掩码字节k
	u8 j = A[i / 8], k = 1 << (i % 8);
	return ((j & k) == 0x00) ? 0:1;
}
//-----------------------------------------------------------------
// 将存放于8字节数组A中的ROMCODE的第i位设为0/1
//-----------------------------------------------------------------
void Save_ROMCODE_Bit_i(u8 A[],u8 i,u8 b) { 
	//先求出64位中的第i位所在的字节在数组中的索引j
	//再根据该位在此字节内8位中的位置(i % 8)得出掩码字节k
	//例如要设第3位为1,则有k = 1 << 3 = 0B00001000.
	u8 j = i / 8, k = 1 << (i % 8);  
	//相应位设为1或0
	if (b == 1)  A[j] |= k; else A[j] &= ~k;
}
//-----------------------------------------------------------------
// 根据ROMCODE码读取温度数据
//-----------------------------------------------------------------
float Get_Temperature(char *rom_code) {
	RESET();						//复位
	ROMCODE_Match(rom_code);		//发ROMCODE匹配命令
	Write_Byte(CONVERT);			//温度转换命令
	//12位分辩率转换时间为750ms
	delay_ms(200);delay_ms(200);
	delay_ms(200);delay_ms(150);
	RESET();						//复位
	ROMCODE_Match(rom_code);		//发ROMCODE匹配命令
	Write_Byte(READ_SCRATCHPAD);	//读RAM命令
	Temp_Value[0] = Read_Byte();	//读取两字节温度数据
	Temp_Value[1] = Read_Byte();
	//计算浮点温度值并返回
	return (int)((Temp_Value[1]<<8) | Temp_Value[0]) * 0.0625;
}
//-----------------------------------------------------------------
// 发送匹配命令,并发送64位的ROMCODE
//-----------------------------------------------------------------
void ROMCODE_Match(u8 ROMCODE[]) { 
	u8 i;
	//先发送ROM匹配命令,然后发送64位的ROMCODE
	Write_Byte(MATCH_ROM);
	for ( i = 0;i < 8; i++)  Write_Byte(ROMCODE[i]);
}
//-----------------------------------------------------------------
// 基于比特的CRC_8校验函数 （速度较慢，本例未调用）
// (通过该函数可预先得出256字节的校验码表,改用查表法进行校验)
// 校验多项式: x^8 + x ^ 5 + x ^ 4 + 1, 去高位后倒序:0x8C
//-----------------------------------------------------------------
/*void CRC_8(u8 d) {
	u8 i;
	for( i = 0; i < 8; i++ ) {
		//CRC待右移出的低位与参与校验字节d的第i位相异
		if ((CRC8 ^ (d >> i)) & 0x01) {
			 //则CRC右移1位,然后与生成多项式编码0x8C异或
			 CRC8 >>= 1 ; CRC8 ^= 0x8C; 
		}
		else CRC8 >>= 1; //否则仅右移1位(实际上这里省略了与0x00的异或)
	}
}*/
//-----------------------------------------------------------------
// CRC_8校验码表(共256字字,该码表通过TC程序调用上述函数计算得到)
//-----------------------------------------------------------------
code u8 CRC_T8[] = {
	0x00,0x5E,0xBC,0xE2,0x61,0x3F,0xDD,0x83,0xC2,0x9C,
	0x7E,0x20,0xA3,0xFD,0x1F,0x41,0x9D,0xC3,0x21,0x7F,
	0xFC,0xA2,0x40,0x1E,0x5F,0x01,0xE3,0xBD,0x3E,0x60,
	0x82,0xDC,0x23,0x7D,0x9F,0xC1,0x42,0x1C,0xFE,0xA0,
	0xE1,0xBF,0x5D,0x03,0x80,0xDE,0x3C,0x62,0xBE,0xE0,
	0x02,0x5C,0xDF,0x81,0x63,0x3D,0x7C,0x22,0xC0,0x9E,
	0x1D,0x43,0xA1,0xFF,0x46,0x18,0xFA,0xA4,0x27,0x79,
	0x9B,0xC5,0x84,0xDA,0x38,0x66,0xE5,0xBB,0x59,0x07,
	0xDB,0x85,0x67,0x39,0xBA,0xE4,0x06,0x58,0x19,0x47,
	0xA5,0xFB,0x78,0x26,0xC4,0x9A,0x65,0x3B,0xD9,0x87,
	0x04,0x5A,0xB8,0xE6,0xA7,0xF9,0x1B,0x45,0xC6,0x98,
	0x7A,0x24,0xF8,0xA6,0x44,0x1A,0x99,0xC7,0x25,0x7B,
	0x3A,0x64,0x86,0xD8,0x5B,0x05,0xE7,0xB9,0x8C,0xD2,
	0x30,0x6E,0xED,0xB3,0x51,0x0F,0x4E,0x10,0xF2,0xAC,
	0x2F,0x71,0x93,0xCD,0x11,0x4F,0xAD,0xF3,0x70,0x2E,
	0xCC,0x92,0xD3,0x8D,0x6F,0x31,0xB2,0xEC,0x0E,0x50,
	0xAF,0xF1,0x13,0x4D,0xCE,0x90,0x72,0x2C,0x6D,0x33,
	0xD1,0x8F,0x0C,0x52,0xB0,0xEE,0x32,0x6C,0x8E,0xD0,
	0x53,0x0D,0xEF,0xB1,0xF0,0xAE,0x4C,0x12,0x91,0xCF,
	0x2D,0x73,0xCA,0x94,0x76,0x28,0xAB,0xF5,0x17,0x49,
	0x08,0x56,0xB4,0xEA,0x69,0x37,0xD5,0x8B,0x57,0x09,
	0xEB,0xB5,0x36,0x68,0x8A,0xD4,0x95,0xCB,0x29,0x77,
	0xF4,0xAA,0x48,0x16,0xE9,0xB7,0x55,0x0B,0x88,0xD6,
	0x34,0x6A,0x2B,0x75,0x97,0xC9,0x4A,0x14,0xF6,0xA8,
	0x74,0x2A,0xC8,0x96,0x15,0x4B,0xA9,0xF7,0xB6,0xE8,
	0x0A,0x54,0xD7,0x89,0x6B,0x35
};
//-----------------------------------------------------------------
// CRC_8查表校验函数(生成多项式为: x^8 + x ^ 5 + x ^ 4 + 1)
//-----------------------------------------------------------------
void CRC_8(u8 d) { CRC8 = CRC_T8[CRC8 ^ d]; }