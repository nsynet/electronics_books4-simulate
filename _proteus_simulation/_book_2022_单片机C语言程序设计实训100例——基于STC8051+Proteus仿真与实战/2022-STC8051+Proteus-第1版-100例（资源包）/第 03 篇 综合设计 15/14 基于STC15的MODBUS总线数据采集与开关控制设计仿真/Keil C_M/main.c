//----------------------- MODBUS主机 main.c ------------------------
//  名称:  基于MODBUS总线的数据采集与开关控制系统设计仿真(主机程序)
//-----------------------------------------------------------------
//  说明: 本例运行时,主机向各从机发送要求返回A/D转换值的命令码或
//		  开/关状态主机完整接收到相关信息后,在液晶上刷新显示.
//
//-----------------------------------------------------------------
#define u8  unsigned char
#define u16 unsigned int
#define u32 unsigned long
#define MAIN_Fosc		11059200L	//系统时钟频率11.0592MHz
#include "STC15xxx.h"
#include <intrins.h>
#include <stdio.h>
#define  ADC_REQ	65				//返回A/D值命令
#define  RELAY_ON	66				//继电器闭合命令
#define  RELAY_OFF	67				//继电器断开命令
//9600波特率每字符时间为: 1/9600*(1+8+1) ≈  1041.66us
//帧  间: 3.5个字符时间为: 1041.66 * (3.5 + 1) ≈ 4687.5us
//字节间: 1.5个字符时间为: 1041.66 * (1.5 + 1) ≈ 2604.2us
#define FRAME_SPAN	4688			//相临帧之间的间隔时间
#define BYTE_SPAN	2604			//帧内字节之间的间隔时间
code char* Prompts[17] = {
	" RS-485  MODBUS ",
	"****************",
	"  TEST PROGRAM  ",
	"****************"
};
volatile u8 recv_Data[6];			//串口接收数据缓冲区(6字节)
volatile u8 recv_idx = 0;			//串口接收数据缓冲区索引
volatile u8 sl_Addr,CMD_CODE;		//485从机地址,命令码字节
u8	 LCD_Buffer[21];				//LCD显示缓冲
bit	 F_T0, T_BYTE, T_FRAME, Recv_OK;//相关标识位
sbit LED_Recv = P0^4;				//主机接收指示灯
sbit LED_Send = P0^7;				//主机发送指示灯
sbit RDE_485 =	 P3^7;				//RS485通信控制端
bit	 ST_K1 = 0,ST_K2 = 0;			//K1,K2按键初始状态
extern void Initialize_LCD();		//LCD初始化
extern void LCD_ShowString(u8 r, u8 c,char *str);//LCD显示
u16 uCRC16;							//CRC16校验码
void CRC_16(u8 d);					//CRC16校验函数
bit TX1_Busy;						//发送忙标志
//-----------------------------------------------------------------
// 延时函数
//-----------------------------------------------------------------
extern void delay_ms(u8);
//-----------------------------------------------------------------
// 宏定义: 发送一字节并等待发送结束
//-----------------------------------------------------------------
#define Send_Byte(x) {						\
	LED_Send = 1;	RDE_485 = 1;			\
	SBUF = x;		TX1_Busy = 1;			\
	while(TX1_Busy);						\
	LED_Send = 0;							\
}
//-----------------------------------------------------------------
// 宏定义: 设置TIMER0的定时初值并设相关标志位(振荡器频率11.0592MHz)
//-----------------------------------------------------------------
#define Set_TIMER0(x) {						\
	AUXR &= 0x7F;	/*定时器时钟12T模式*/	\
	TMOD &= 0xF0;	/*设置定时器模式*/		\
	TMOD |= 0x01;							\
	TH0 = (u16)(-11.0592/12.0 * x) >> 8;	\
	TL0 = (u16)(-11.0592/12.0 * x) & 0xFF;	\
	TF0 = T_BYTE = T_FRAME = 0;				\
	F_T0 =(x == FRAME_SPAN) ?1:0;			\
	if (F_T0) recv_idx = 0;					\
}
//-----------------------------------------------------------------
// 串口初始化
//-----------------------------------------------------------------
void UartInit() {		//9600bps@11.0592MHz

}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	u8 i,t;
	P0M1 = 0x00; P0M0 = 0x00;	//P0~P3配置为准双向口
	P1M1 = 0x00; P1M0 = 0x00;	
	P2M1 = 0x00; P2M0 = 0x00;	
	P3M1 = 0x00; P3M0 = 0x00;	
	Initialize_LCD();			//LCD初始化
	//输出系统封面文字(4行)
	for (i = 0; i < 4; i++) LCD_ShowString(i,0,(char*)Prompts[i]);
	//等待足够时间,待从机完成初始化
	delay_ms(200);delay_ms(200);
	LED_Recv=1; LED_Send=1;		//主机收/发指示灯均熄灭
	UartInit();					//串口初始化配置
	//中断配置
	ES = 1; ET0 = 1;			//允许串口中断与T0溢出中断
	EX0 = 1; EX1 = 1;			//允许INT0,INT1中断
	IT0 = 1; IT1 = 1;			//下降沿触发
	PX0 = 1; PX1 = 1;			//设置优先级
	Recv_OK = 0;				//初始时设接收成功标识为假
	RDE_485 = 1;				//允许485发送
	TR0 = 1;					//启动T0定时器
	EA = 1;						//开中断
	while(1) {
		//---------------------------------------------------------
		// 循环访问地址为0x01~0x04的4个485从机
		//---------------------------------------------------------
		for (sl_Addr = 0x01; sl_Addr <= 0x04; sl_Addr++) {
			LED_Send = 0;				//主机发送指示灯开
			RDE_485 = 1;				//允许485发送(禁止接收)
			delay_ms(5);
			uCRC16 = 0xFFFF;			//校验码初值统一约定为0xFFFF
			CRC_16(sl_Addr);			//当前从机地址校验
			switch (sl_Addr) {			//选择待发送的命令码
				case 0x01: CMD_CODE = (ST_K1)? RELAY_ON:RELAY_OFF;break;
				case 0x02: CMD_CODE = (ST_K2)? RELAY_ON:RELAY_OFF;break;
				case 0x03: case 0x04: CMD_CODE = ADC_REQ; break;
			}
			CRC_16(CMD_CODE);			//当前操作命令码校验
			Send_Byte(sl_Addr);			//(1)发送从机地址
			Send_Byte(CMD_CODE);		//(2)发送命令码字节
			Send_Byte(uCRC16);			//(3)发送校验码低字节
			Send_Byte(uCRC16>>8);		//(4)发送校验码高字节
			Set_TIMER0(FRAME_SPAN);		//用TIMER0控制相邻帧之间的时间间隔
			Recv_OK = 0;				//先设接收成功标识为假
			RDE_485 = 0;				//允许485接收(禁止发送)
			LED_Send = 1;				//主机发送指示灯关
			//如果主机接收从机数据未完成且未超时(30ms)则等待 
			t = 30; while (!Recv_OK && --t) delay_ms(1);
			//-----------------------------------------------------
			//如果主机接收从数据成功则继续下面的处理
			if (Recv_OK) {
				EA = 0;					//关中断
				Recv_OK = 0;			//接收成功标志重设为假
				uCRC16 = 0xFFFF;		//校验码初值统一约定为0xFFFF
				//对来自当前从机的6字节数据进行CRC16校验
				for (i = 0; i < 6; i++) CRC_16(recv_Data[i]);
				//校验通过时显示
				if (uCRC16 == 0x0000) {
	 				LED_Send = 1;		//主机发送指示灯关闭
					//从机发送的6字节分别是：
					//站号/命令码/两字节数据/两字节uCRC16
					//recv_Data[2],[3]所保存的是从机返回数据
					//下面的代码生成待显示字符串并送LCD显示
					if (sl_Addr >= 0x03) {	//针对从机3，4显示模拟电压
						sprintf(LCD_Buffer, "#%d: %4.2fV  %4.2fV",
						(int)sl_Addr,
						(float)((int)recv_Data[2] * 5.0 / 256.0),
						(float)((int)recv_Data[3] * 5.0 / 256.0));
						//发送到LCD显示(显示LCD的下两行,每行显示两组)
						LCD_ShowString(sl_Addr-1,0,LCD_Buffer);
					}
					else {				//针对从机1，2显示开关状态 
						sprintf(LCD_Buffer, "#%d: %3s",(int)sl_Addr,
							(recv_Data[2]==0)?"ON":"OFF");
						LCD_ShowString(0, (sl_Addr-1) * 8,LCD_Buffer);
					}
				}
			}
			//每完成一个从机数据处理后延时10ms再开中断
			delay_ms(10); EA = 1; 
			//-----------------------------------------------------
		}
		delay_ms(10); //每完成一轮(4个从机)扫描后等待10ms
	}
} 
//-----------------------------------------------------------------
// 串口接收中断
//-----------------------------------------------------------------
void SerialPort_INT() interrupt 4 {
	u8 R;
	if (RI) {
		RI = 0;							//清标志位
		LED_Recv = ~LED_Recv;			//主机接收指示灯闪烁
		R = SBUF;						//从串口(来自485)读取一字节
		Recv_OK = 0;					//先暂时设接收成功标志为假
		//---------------------------------------------------------
		//如果当前要接收的是第0字节
		if (recv_idx == 0) { 
			//如果帧间时间间隔未到,或所收到的字节与设备地址不匹配
			//则重新设TIMER1定时长度为帧间时长FRAME_SPAN
			if (T_FRAME == 0 || R != sl_Addr) { Set_TIMER0(FRAME_SPAN); }
			//否则表示接收的第0个字节与其设备地址匹配
			else {
				recv_Data[recv_idx++] = R; //字节R保存到接收缓冲recv_Data
				Set_TIMER0(BYTE_SPAN);	//重设T0定时长度为帧内字节间的时长
			}
		}
		//---------------------------------------------------------
		//否则要接收的是第0字节（即地址字节）之后的数据
		else { 
			//如果后续接收过程中帧内字节时间间隔未超过1.5个字符时间
			if (T_BYTE == 0) {
				recv_Data[recv_idx++] = R;	//首先将有效字节保存到接收缓冲
				//如果接收到地址字节(第0字节)后的字节(即第1字节)不等于操作码
				//则将接收缓冲索引归0,并重设T0定时长度为帧间隔时长
				//(注意recv_idx == 2时,刚刚保存R是第1字节）
				if ( recv_idx == 2 && R != CMD_CODE) { 
					Set_TIMER0(FRAME_SPAN); }
				//如果接收到来自当前从机的完整的6个字节数据
				else if (recv_idx == 6) {
					Set_TIMER0(FRAME_SPAN);	//重设T0定时长度为帧间隔时长
					Recv_OK = 1;			//设置接收成功标识为真
				}
				else {	//重设T0定时长度为帧内字节间时长
					Set_TIMER0(BYTE_SPAN);
				}
			}
			//同一帧内字符间的时间超时,重设T1为帧之间的时间间隔 
			else  { Set_TIMER0(FRAME_SPAN); }
		}
	}
	if (TI) { TI = 0; TX1_Busy = 0; }
}
//-----------------------------------------------------------------
// TIMER0定时器溢出中断
//-----------------------------------------------------------------
void TIMER0_OVF_INT() interrupt 1 {


}
//-----------------------------------------------------------------
// INT0中断(P3.2 K1按键)
//-----------------------------------------------------------------
void EX_INT0() interrupt 0 {


}
//-----------------------------------------------------------------
// INT1中断(P3.3 K2按键)
//-----------------------------------------------------------------
void EX_INT1() interrupt 2 {


}
//-----------------------------------------------------------------
// CRC_16校验函数 (基于该函数可得出512字节的校验码表,改用查表法进行校验)
// 多项式: X ^ 16 + X ^ 15 + X ^ 2 + 1, 去高位逆序表示:0xA001
//-----------------------------------------------------------------
//void CRC_16(u8 d) {
//	u8 i;
//	for ( i = 0; i < 8; i++) {
//		//uCRC16待右移出的低位与参与校验字节d的第i位相异
//		if ((uCRC16 ^ (d >> i)) & 0x01) {
//			//则uCRC16右移1位,然后与生成多项式编码0xA001异或
//			uCRC16 >>= 1 ; uCRC16 ^= 0xA001; 
//		}	else uCRC16 >>= 1; //否则仅右移1位(这里省略了与0x0000异或)
//	}
//}
//-----------------------------------------------------------------
// CRC_16校验码表(由上面的比特型CRC16校验函数生成，共256项，512字节)
//-----------------------------------------------------------------
code u16 CRC_T16[] = {
	0x0000,0xC0C1,0xC181,0x0140,0xC301,0x03C0,0x0280,0xC241,0xC601,0x06C0,
	0x0780,0xC741,0x0500,0xC5C1,0xC481,0x0440,0xCC01,0x0CC0,0x0D80,0xCD41,
	0x0F00,0xCFC1,0xCE81,0x0E40,0x0A00,0xCAC1,0xCB81,0x0B40,0xC901,0x09C0,
	0x0880,0xC841,0xD801,0x18C0,0x1980,0xD941,0x1B00,0xDBC1,0xDA81,0x1A40,
	0x1E00,0xDEC1,0xDF81,0x1F40,0xDD01,0x1DC0,0x1C80,0xDC41,0x1400,0xD4C1,
	0xD581,0x1540,0xD701,0x17C0,0x1680,0xD641,0xD201,0x12C0,0x1380,0xD341,
	0x1100,0xD1C1,0xD081,0x1040,0xF001,0x30C0,0x3180,0xF141,0x3300,0xF3C1,
	0xF281,0x3240,0x3600,0xF6C1,0xF781,0x3740,0xF501,0x35C0,0x3480,0xF441,
	0x3C00,0xFCC1,0xFD81,0x3D40,0xFF01,0x3FC0,0x3E80,0xFE41,0xFA01,0x3AC0,
	0x3B80,0xFB41,0x3900,0xF9C1,0xF881,0x3840,0x2800,0xE8C1,0xE981,0x2940,
	0xEB01,0x2BC0,0x2A80,0xEA41,0xEE01,0x2EC0,0x2F80,0xEF41,0x2D00,0xEDC1,
	0xEC81,0x2C40,0xE401,0x24C0,0x2580,0xE541,0x2700,0xE7C1,0xE681,0x2640,
	0x2200,0xE2C1,0xE381,0x2340,0xE101,0x21C0,0x2080,0xE041,0xA001,0x60C0,
	0x6180,0xA141,0x6300,0xA3C1,0xA281,0x6240,0x6600,0xA6C1,0xA781,0x6740,
	0xA501,0x65C0,0x6480,0xA441,0x6C00,0xACC1,0xAD81,0x6D40,0xAF01,0x6FC0,
	0x6E80,0xAE41,0xAA01,0x6AC0,0x6B80,0xAB41,0x6900,0xA9C1,0xA881,0x6840,
	0x7800,0xB8C1,0xB981,0x7940,0xBB01,0x7BC0,0x7A80,0xBA41,0xBE01,0x7EC0,
	0x7F80,0xBF41,0x7D00,0xBDC1,0xBC81,0x7C40,0xB401,0x74C0,0x7580,0xB541,
	0x7700,0xB7C1,0xB681,0x7640,0x7200,0xB2C1,0xB381,0x7340,0xB101,0x71C0,
	0x7080,0xB041,0x5000,0x90C1,0x9181,0x5140,0x9301,0x53C0,0x5280,0x9241,
	0x9601,0x56C0,0x5780,0x9741,0x5500,0x95C1,0x9481,0x5440,0x9C01,0x5CC0,
	0x5D80,0x9D41,0x5F00,0x9FC1,0x9E81,0x5E40,0x5A00,0x9AC1,0x9B81,0x5B40,
	0x9901,0x59C0,0x5880,0x9841,0x8801,0x48C0,0x4980,0x8941,0x4B00,0x8BC1,
	0x8A81,0x4A40,0x4E00,0x8EC1,0x8F81,0x4F40,0x8D01,0x4DC0,0x4C80,0x8C41,
	0x4400,0x84C1,0x8581,0x4540,0x8701,0x47C0,0x4680,0x8641,0x8201,0x42C0,
	0x4380,0x8341,0x4100,0x81C1,0x8081,0x4040
};
//-----------------------------------------------------------------
// CRC_16校验函数(查表法)
//-----------------------------------------------------------------
void CRC_16(u8 d) {uCRC16 = ( uCRC16 >> 8 )^CRC_T16[(uCRC16 & 0xFF)^d];}
