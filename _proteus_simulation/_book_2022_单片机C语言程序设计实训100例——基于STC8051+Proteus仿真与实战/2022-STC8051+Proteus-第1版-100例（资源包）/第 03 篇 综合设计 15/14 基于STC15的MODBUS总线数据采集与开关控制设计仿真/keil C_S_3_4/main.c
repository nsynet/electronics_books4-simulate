//-----------------------从机3,4 main.c-----------------------------
//  名称: MODBUS总线通信仿真(从机程序)--ADC0832双通道8位精度A/D转换
//-----------------------------------------------------------------
//  说明: 从机接到主机A/D命令后将当前A/D转换值回发主机LCD刷新显示.
//		
//-----------------------------------------------------------------
#define u8		unsigned char
#define u16		unsigned int
#define uu32	unsigned long
#include <reg51.h>
#include <intrins.h>
#include <stdio.h>
#define  ADC_REQ  65				//返回A/D值命令码
#define  SW_STAT  66				//返回开关状态命令
//9600波特率每字符时间为: 1/9600*(1+8+1) ≈  1041.66us
//帧  间: 3.5个字符时间为: 1041.66 * (3.5 + 1) ≈ 4687.5us
//字节间: 1.5个字符时间为: 1041.66 * (1.5 + 1) ≈ 2604.2us
#define FRAME_SPAN  4688		//相临帧之间的间隔时间
#define BYTE_SPAN	2604		//帧内字节之间的间隔时间
volatile u8 recv_Data[6];		//串口接收数据缓冲区(6字节)
volatile u8 recv_idx = 0;		//串口接收数据缓冲区索引
volatile u8 sl_Addr;			//485从机地址
u16 uCRC16;						//16位CRC校验结果
bit	b, F_T0, T_BYTE, T_FRAME, Recv_OK;//相关标识位
sbit  LED_Ptr = P1^4;			//LED指示灯
sbit  RDE_485 =	P1^7;			//RS485通信控制端
extern u8 ADx_Value(u8);		//ADC0832 A/D转换函数
//-----------------------------------------------------------------
// 宏定义: 发送一字节并等待发送结束
//-----------------------------------------------------------------
#define Send_Byte(x) {							\
	LED_Ptr = ~LED_Ptr;							\
	RDE_485 = 1; SBUF = x;						\
	while (TI == 0); TI = 0;					\
	LED_Ptr = 1;								\
}
//-----------------------------------------------------------------
// 宏定义: 设置TIMER0的定时初值并设相关标志位(振荡器频率11.0592MHz)
//-----------------------------------------------------------------
#define Set_TIMER0(x) {							\
	TH0 = (u16)(-11.0592/12.0 * x) >> 8;		\
	TL0 = (u16)(-11.0592/12.0 * x) & 0xFF;		\
	TF0 = T_BYTE = T_FRAME = 0;					\
	F_T0 =(x == FRAME_SPAN) ?1:0;				\
	if (F_T0) recv_idx = 0;						\
}
//-----------------------------------------------------------------
// 延时函数
//-----------------------------------------------------------------
void delay_ms(u16 x) {u8 t; while(x--) for(t = 0; t<120; t++);}
//-----------------------------------------------------------------
// CRC_16校验函数 (基于该函数可得出512字节的校验码表,改用查表法进行校验)
// 多项式: X ^ 16 + X ^ 15 + X ^ 2 + 1, 去高位逆序表示:0xA001
//-----------------------------------------------------------------
void CRC_16(u8 d) {
	u8 i;
	for ( i = 0; i < 8; i++) {
		if ((uCRC16^ (d >> i)) & 0x01)	{uCRC16>>= 1 ; uCRC16^= 0xA001; }
		else uCRC16>>= 1;
	}
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	u8 i, ADC_CH0, ADC_CH1;					//CH0,1通道A/D值
	sl_Addr = P1 & 0x0F;					//读取本机地址
	//串口配置
	TMOD = 0x21;							//T1工作于方式2,T0工作于方式1
	SCON = 0x51;							//串口方式1,允许接收
	PCON = 0x00;							//波特率不倍增
	TH1 = TL1 = 0xFD;						//BaudRate:9600 11.0592MHZ 
	TI = RI = 0;							//串口中断标志软件清0
	//中断配置
	TR0 = 1;								//启动T0定时器
	TR1 = 1;								//启动T1定时器
	ES = 1; ET0 = 1;						//允许串口中断与T0溢出中断
	EA = 1;									//开中断
	Recv_OK = 0;							//初始时设接收成功标识为假
	RDE_485 = 0;							//使能485接收
	while(1) {
		//如果本从机已经接收到完整的四个字节数据
		if (Recv_OK) {
			EA = 0;							//关中断
			Recv_OK = 0;					//接收成功标志重设为假 
			//对来自主机的4字节数据进行CRC校验(初值统一约定为0xFFFF) 
			uCRC16= 0xFFFF;  for( i = 0; i < 4; i++) CRC_16(recv_Data[i]);
			///校验通过后向主机发送6字节(本机地址,操作码,2字节A/D,2字节CRC)
			if (uCRC16== 0x0000) {
				RDE_485 = 1; delay_ms(5);	//允许发送，禁止接收
				ADC_CH0 = ADx_Value(0);		//ADC0832 0通道模/数转换
				ADC_CH1 = ADx_Value(1);		//ADC0832 1通道模/数转换
				uCRC16 = 0xFFFF;			//校验码初值统一约定为0xFFFF
				CRC_16(sl_Addr);			//校验本机地址
				CRC_16(ADC_REQ);			//校验A/D请求命令
				CRC_16(ADC_CH0);			//校验A/D结果高字节
				CRC_16(ADC_CH1);			//校验A/D结果低字节
				Send_Byte(sl_Addr);			//回发本机地址
				Send_Byte(ADC_REQ);			//回发A/D请求命令
				Send_Byte(ADC_CH0);			//回发0通道AD值
				Send_Byte(ADC_CH1);			//回发1通道AD值
				Send_Byte(uCRC16);			//发送CRC校验码低字节
				Send_Byte(uCRC16>>8);		//发送CRC校验码高字节
				RDE_485 = 0;delay_ms(5);	//发送结束后再允许本机RS-485接收
			}
			EA = 1;							//开中断
		}
	}
}
//-----------------------------------------------------------------
// 串口接收中断
//-----------------------------------------------------------------
void SerialPort_INT() interrupt 4 {
	u8 R;
	LED_Ptr = ~LED_Ptr;					//从机接收时指示灯闪烁
	R = SBUF;							//从串口(来自485)读取一字节
	RI = 0;								//清标志位
	Recv_OK = 0;						//先暂时设接收成功标志为假
	//---------------------------------------------------------
	//如果当前要接收的是第0字节
	if (recv_idx == 0) { 
		//如果帧间时间间隔未到,或所收到的字节与设备地址不匹配
		//则重新设TIMER1定时长度为帧间时长FRAME_SPAN
		if (T_FRAME == 0 || R != sl_Addr) { Set_TIMER0(FRAME_SPAN); }
		//否则表示接收的第0个字节与其设备地址匹配
		else {
 			recv_Data[recv_idx++] = R;	//字节R保存到接收缓冲recv_Data
			Set_TIMER0(BYTE_SPAN);		//重设T0定时长度为帧内字节间的时长
 		}
	}
	//---------------------------------------------------------
	//否则要接收的是第0字节（即地址字节）之后的数据
	else {
		//如果后续接收过程中帧内字节时间间隔未超过1.5个字符时间
		if (T_BYTE == 0) {
			recv_Data[recv_idx++] = R;	//首先将有效字节保存到接收缓冲
			//如果接收到的地址字节（第0字节）后的字节（即第1字节）不等于操作码
			//则将接收缓冲索引归0,并重设T0定时长度为帧间隔时长
			//(注意recv_idx == 2时,刚刚保存R是第1字节）
			if ( recv_idx == 2 && R != ADC_REQ) { Set_TIMER0(FRAME_SPAN); }
			//如果接收到来自当前主机的完整的4个字节数据
			else if (recv_idx == 4) {
				Set_TIMER0(FRAME_SPAN);	//重设T0定时长度为帧间隔时长
				Recv_OK = 1;			//设置接收成功标识为真
			}
			else {Set_TIMER0(BYTE_SPAN);}//重设T0定时长度为帧内字节间的时长
		}
		//同一帧内字符间的时间超时,重设T1为帧之间的时间间隔 
		else  { Set_TIMER0(FRAME_SPAN); }
	}
}
//-----------------------------------------------------------------
// TIMER0定时器溢出中断
//-----------------------------------------------------------------
void TIMER0_OVF_INT() interrupt 1 {


}