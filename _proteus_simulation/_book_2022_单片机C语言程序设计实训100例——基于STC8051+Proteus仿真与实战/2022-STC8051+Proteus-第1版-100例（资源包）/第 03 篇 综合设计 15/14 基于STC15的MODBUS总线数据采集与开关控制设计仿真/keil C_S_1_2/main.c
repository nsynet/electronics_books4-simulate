//-----------------------从机1,2 main.c-----------------------------
//  名称: MODBUS总线通信仿真(从机程序)--Modbus从机-开关控制
//-----------------------------------------------------------------
//  说明: 从机接收到主机控制命令后切换继电器开关,并回发当前开关状态.
//
//-----------------------------------------------------------------
#define u8		unsigned char
#define u16		unsigned int
#define uu32	unsigned long
#include <reg51.h>
#include <intrins.h>
#include <stdio.h>
#define  RELAY_ON	66				//继电器闭合命令
#define  RELAY_OFF	67				//继电器断开命令
//9600波特率每字符时间为: 1/9600*(1+8+1) ≈  1041.66us
//帧  间: 3.5个字符时间为: 1041.66 * (3.5 + 1) ≈ 4687.5us
//字节间: 1.5个字符时间为: 1041.66 * (1.5 + 1) ≈ 2604.2us
#define FRAME_SPAN  4688			//相临帧之间的间隔时间
#define BYTE_SPAN	2604			//帧内字节之间的间隔时间
volatile u8 recv_Data[6];			//串口接收数据缓冲区(6字节)
volatile u8 recv_idx = 0;			//串口接收数据缓冲区索引
volatile u8 sl_Addr;				//485从机地址
u16 uCRC16;							//CRC校验结果
volatile bit  Recv_OK;				//相关标识位
volatile bit F_T0, T_BYTE, T_FRAME;//相关标识位
sbit  LED_Ptr = P1^4;				//LED指示灯
sbit  RDE_485 =	P1^7;				//RS485通信控制端
sbit  SW = P3^2;					//开关控制线
//-----------------------------------------------------------------
// 宏定义: 发送一字节并等待发送结束
//-----------------------------------------------------------------
#define Send_Byte(x) {						\
	LED_Ptr = ~LED_Ptr;						\
	RDE_485 = 1; SBUF = x;					\
	while (TI == 0); TI = 0;				\
	LED_Ptr = 1;							\
}

//-----------------------------------------------------------------
// 宏定义: 设置TIMER0的定时初值并设相关标志位(振荡器频率11.0592MHz)
//-----------------------------------------------------------------
#define Set_TIMER0(x) {						\
	TH0 = (u16)(-11.0592/12.0 * x) >> 8;	\
	TL0 = (u16)(-11.0592/12.0 * x) & 0xFF;	\
	TF0 = T_BYTE = T_FRAME = 0;				\
	F_T0 =(x == FRAME_SPAN) ?1:0;			\
	if (F_T0) recv_idx = 0;					\
}
//-----------------------------------------------------------------
// 延时函数
//-----------------------------------------------------------------
void delay_ms(u16 x) {u8 t; while(x--) for(t = 0; t<120; t++);}
//-----------------------------------------------------------------
// CRC_16校验函数 (基于该函数可得出512字节的校验码表,改用查表法进行校验)
// 多项式: X ^ 16 + X ^ 15 + X ^ 2 + 1, 去高位逆序表示:0xA001
//-----------------------------------------------------------------
void CRC_16(u8 d) {



}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	u8 i;
	sl_Addr = P1 & 0x0F;					//读取本机地址
	//串口配置
	TMOD = 0x21;							//T1工作于方式2,T0工作于方式1
	SCON = 0x51;							//串口方式1,允许接收
	PCON = 0x00;							//波特率不倍增
	TH1 = TL1 = 0xFD;						//BaudRate:9600 11.0592MHZ 
	TI = RI = 0;							//串口中断标志软件清0
	//中断配置
	TR0 = 1;								//启动T0定时器
	TR1 = 1;								//启动T1定时器
	ES = 1; ET0 = 1;						//允许串口中断与T0溢出中断
	EA = 1;									//开中断
	Recv_OK = 0;							//初始时设接收成功标识为假
	RDE_485 = 0;							//使能485接收
	while(1) {
		//如果本从机已经接收到完整的四个字节数据
		if (Recv_OK) {
			EA = 0;							//关中断
			Recv_OK = 0;					//接收成功标志重设为假 
			//对来自主机的4个字节数据进行CRC校验(初始值统一约定为0xFFFF)
			uCRC16= 0xFFFF;  for( i = 0; i < 4; i++) CRC_16(recv_Data[i]);
			//校验通过后开始向主机发送数据
			//(6字节:本机地址,操作码,开关状态,补齐字节,两字节CRC)
			if (uCRC16 == 0x0000) {
				RDE_485 = 1;delay_ms(10);	//允许发送，禁止接收
				SW = (recv_Data[1] == RELAY_ON)? 0:1;//执行开关命令
				uCRC16 = 0xFFFF;			//校验码初值统一约定为0xFFFF
				CRC_16(sl_Addr);			//校验本机地址
				CRC_16(recv_Data[1]);		//校验开关命令
				CRC_16(SW);					//校验开关状态值
				CRC_16(0x00);				//为简化主机程序,用0x00补齐
				Send_Byte(sl_Addr);			//回发本机地址
				Send_Byte(recv_Data[1]);	//回发开关状态命令
				Send_Byte(SW);				//回发开关状态值
				Send_Byte(0x00);			//回发补齐的0x00字节
				Send_Byte(uCRC16);			//发送CRC校验码低字节
				Send_Byte(uCRC16>>8);		//发送CRC校验码高字节
				RDE_485 = 0;delay_ms(5);	//发送结束后,再允许本机485接收
			}
			EA = 1;							//开中断
		}
	}
}
//-----------------------------------------------------------------
// 串口接收中断
//-----------------------------------------------------------------
void SerialPort_INT() interrupt 4 {
	u8 R;
	LED_Ptr = ~LED_Ptr;						//从机接收时指示灯闪烁
	R = SBUF;								//从串口(来自485)读取一字节
	RI = 0;									//清标志位
	Recv_OK = 0;							//先暂时设接收成功标志为假
	//---------------------------------------------------------
	//如果当前要接收的是第0字节
	if (recv_idx == 0) {
		//如果帧间时间间隔未到,或所收到的字节与设备地址不匹配
		//则重新设TIMER1定时长度为帧间时长FRAME_SPAN
		if (T_FRAME == 0 || R != sl_Addr) { Set_TIMER0(FRAME_SPAN); }
		//否则表示接收的第0个字节与其设备地址匹配
		else {
 			recv_Data[recv_idx++] = R;	//字节R保存到接收缓冲recv_Data
			Set_TIMER0(BYTE_SPAN);		//重设T0定时长度为帧内字节间的时长
 		}
	}
	//---------------------------------------------------------
	//否则要接收的是第0字节（即地址字节）之后的数据
	else {
		//如果后续接收过程中帧内字节时间间隔未超过1.5个字符时间
		if (T_BYTE == 0) {
			recv_Data[recv_idx++] = R;	//首先将有效字节保存到接收缓冲
			//如果接收到的地址字节（第0字节）后的字节（即第1字节）不等于操作码
			//则将接收缓冲索引归0,并重设T0定时长度为帧间隔时长
			//(注意recv_idx == 2时,刚刚保存R是第1字节）
			if ( recv_idx == 2 && R != RELAY_ON && R != RELAY_OFF) { 
				Set_TIMER0(FRAME_SPAN); }
			//如果接收到来自当前主机的完整的4个字节数据
			else if (recv_idx == 4) {
				Set_TIMER0(FRAME_SPAN);	//重设T0定时长度为帧间隔时长
				Recv_OK = 1;			//设置接收成功标识为真
			}
			else {
				Set_TIMER0(BYTE_SPAN);	//重设T0定时长度为帧内字节间的时长
			}
		}
		//同一帧内字符间的时间超时,重设T1为帧之间的时间间隔
		else  { Set_TIMER0(FRAME_SPAN); }
	}
}
//-----------------------------------------------------------------
// TIMER0定时器溢出中断
//-----------------------------------------------------------------
void TIMER0_OVF_INT() interrupt 1 {



}