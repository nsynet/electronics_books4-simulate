//-----------------------------------------------------------------
//  名称: 硬件PWM控制多路伺服电机运行
//-----------------------------------------------------------------
//  说明: 本例仿真电路中共连接三个伺服电机，前两个由主循环控制以不同
//        速度在0～180°范围内来回摆动，第三个电机在定时器控制下由按键
//        操控左右摆动.
//        
//-----------------------------------------------------------------
#include "STC15xxx.h"
#include <intrins.h>
typedef	unsigned char	u8;
typedef	unsigned int 	u16;
typedef	unsigned long	u32;
//-----------------------------------------------------------------
sbit PWM2	=	P2^7;			//各路PWM输出引脚定义(由PWMxCR配置指定)
sbit PWM3	=	P2^1;
sbit PWM4	=	P2^2;
sbit PWM5	=	P2^3;
sbit PWM6	=	P1^6;
sbit PWM7	=	P1^7;
sbit LED1	=	P3^6;			//指示灯定义
sbit LED2	=	P3^7;
//-----------------------------------------------------------------
void PWM_config();
void PWM2_SetPwmw(u16 w);
void PWM3_SetPwmw(u16 w);
void PWM4_SetPwmw(u16 w);
void PWM5_SetPwmw(u16 w);
void PWM6_SetPwmw(u16 w);
void PWM7_SetPwmw(u16 w);
//-----------------------------------------------------------------
#define MAIN_Fosc	12000000L	//主频定义12MHz
const u16 CYCLE = 2000L;			//定义PWM周期(最大值为32767)
volatile u16 servo3_p = 90;
//-----------------------------------------------------------------
// 延时函数
//-----------------------------------------------------------------
void delay_ms(u8 ms) {			//@12MHz
	u16 i;
	do{
		i = MAIN_Fosc / 13000;
		while(--i);
	 } while(--ms);
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	u16 i = 0;
	PWM_config();
	while (1) {

	}
}
//-----------------------------------------------------------------
// INT0中断：控制正转
//-----------------------------------------------------------------
void EX_INT0() interrupt 0 {
	u8 x = 20; 	EA = 0;
	if ((P3 & (1<<2)) == 0x00) {
		LED1 = 0; LED2 = 1;		//正转指示灯亮
		//Servo 2 - PWM3控制
		while (x-- && servo3_p < 200) { 
			delay_ms(5); PWM4_SetPwmw(servo3_p); servo3_p++;
		}
	}
	EA = 1; 
}
//-----------------------------------------------------------------
// INT1中断：控制反转
//-----------------------------------------------------------------
void EX_INT1() interrupt 2 {

}
//-----------------------------------------------------------------
// PWM配置函数
//-----------------------------------------------------------------
void PWM_config() {
	P1M1 &= 0x3F;	P1M0 &= 0x3F; P1 &= 0x3F;//P1.6-7准双向,初始置低
	P2M1 &= 0x71;	P2M0 &= 0x71; P2 &= 0x71;//P2.1-2-3-7准双向,初始置低
	P3M1 = 0x0C; 	P3M0 = 0x00;	P3 = 0xFF;//P3.2-3高阻输入,其余为准双向
	IT0 = 1;				//INT0下降沿触发
	IT1 = 1;				//INT1下降沿触发
	PX0 = 1;				//设置优先级
	IE = 0x05;				//INT0,INT1开中断
	EA = 1;					//开总中断控制位
	P_SW2 |= 0x80;			//扩展SFR访问控制使能
	PWMCKS = 0x07;			//选择系统时钟,7+1分频,实际为2^7=128分频
	PWMC = CYCLE;			//设置PWM周期=2000*1000/(12M/128)≈21.3ms
	//PWM2~7第1,2次翻转计数初值PWMxT1,PWMxT2分别为1,0
	PWM2T1 = 0;	PWM2T2 = 1;	PWM2CR = 1<<3;	//PWM2输出到P2.7
	PWM3T1 = 0;	PWM3T2 = 1;	PWM3CR = 0x00;	//PWM3输出到P2.1
	PWM4T1 = 0;	PWM4T2 = 1;	PWM4CR = 0x00;	//PWM4输出到P2.2
	PWM5T1 = 0;	PWM5T2 = 1;	PWM5CR = 0x00;	//PWM5输出到P2.3
	PWM6T1 = 0;	PWM6T2 = 1;	PWM6CR = 0x00;	//PWM6输出到P1.6
	PWM7T1 = 0;	PWM7T2 = 1;	PWM7CR = 0x00;	//PWM7输出到P1.7
	PWMCFG = 0x00;			//配置PWM初始电平（均为低电平）
	PWMCR = 0x3F;			//使能PWM2~7共6路PWM输出
	PWMCR |= 0x80;			//使能PWM波形发生器，开始计数
	P_SW2 &= ~0x80;			//扩展SFR访问控制禁止
}
//-----------------------------------------------------------------
// PWM2脉宽设置
//-----------------------------------------------------------------
void PWM2_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x01;	PWM2 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x01;	PWM2 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM2T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x01;
	}
}
//-----------------------------------------------------------------
// PWM3脉宽设置
//-----------------------------------------------------------------
void PWM3_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x02;	PWM3 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x02;	PWM3 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM3T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x02;
	}
}
//-----------------------------------------------------------------
// PWM4脉宽设置
//-----------------------------------------------------------------
void PWM4_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x04;	PWM4 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x04;	PWM4 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM4T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x04;
	}
}
//-----------------------------------------------------------------
// PWM5脉宽设置(本例未使用)
//-----------------------------------------------------------------
void PWM5_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x08;	PWM5 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x08;	PWM5 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM5T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x08;
	}
}
//-----------------------------------------------------------------
// PWM6脉宽设置(本例未使用)
//-----------------------------------------------------------------
void PWM6_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x10;	PWM6 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x10;	PWM6 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM6T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x10;
	}
}
//-----------------------------------------------------------------
// PWM7脉宽设置(本例未使用)
//-----------------------------------------------------------------
void PWM7_SetPwmw(u16 w) {
	if (w == 0)				{	PWMCR &= ~0x20;	PWM7 = 0;	}
	else if (w == CYCLE)	{	PWMCR &= ~0x20;	PWM7 = 1;	}
	else {
		P_SW2 |= 0x80;	PWM7T2 = w;
		P_SW2 &= ~0x80;	PWMCR |= 0x20;
	}
}