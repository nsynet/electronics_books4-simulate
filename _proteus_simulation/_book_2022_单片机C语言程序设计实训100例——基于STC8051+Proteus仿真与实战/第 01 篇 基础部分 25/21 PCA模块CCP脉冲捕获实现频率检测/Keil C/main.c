//-----------------------------------------------------------------
//  名称: PCA模块CCP脉冲捕获实现频率检测 
//-----------------------------------------------------------------
//  说明: 在切换不同的频率输入后按下K1按键,数码管上将显示当前频率值.
//		 两次捕获的时间差值即为当前输入频率的周期,倒数可得频率.
//
//-----------------------------------------------------------------
#include "STC15xxx.h"
#include <intrins.h>
#define u8 	unsigned char
#define u16	unsigned int
#define u32	unsigned long
//-----------------------------------------------------------------
#define FOSC 12000000L
#define CCP_S0 0x10 //P_SW1.4
#define CCP_S1 0x20 //P_SW1.5
//-----------------------------------------------------------------
// 可编程计数器阵列模块（CCP/PCA）相关寄存器定义：已定义于STC15xxx.h
//-----------------------------------------------------------------
//sfr P_SW1 = 0xA2;				//外设功能切换寄存器1
//-----------------------------------------------------------------
//sfr CCON = 0xD8;				//PCA控制寄存器
//sbit CCF0 = CCON^0;			//PCA模块0中断标志
//sbit CCF1 = CCON^1;			//PCA模块1中断标志
//sbit CR = CCON^6;				//PCA定时器运行控制位
//sbit CF = CCON^7;				//PCA定时器溢出标志
//sfr CMOD = 0xD9;				//PCA模式寄存器
//sfr CL = 0xE9;				//PCA定时器低字节
//sfr CH = 0xF9;				//PCA定时器高字节
//-----------------------------------------------------------------
//sfr CCAPM0 = 0xDA;			//PCA模块0模式寄存器
//sfr CCAP0L = 0xEA;			//PCA模块0捕获寄存器 LOW
//sfr CCAP0H = 0xFA;			//PCA模块0捕获寄存器 HIGH
//sfr CCAPM1 = 0xDB;			//PCA模块1模式寄存器
//sfr CCAP1L = 0xEB;			//PCA模块1捕获寄存器 LOW
//sfr CCAP1H = 0xFB;			//PCA模块1捕获寄存器 HIGH
//sfr CCAPM2 = 0xDC;			//PCA模块2模式寄存器
//sfr CCAP2L = 0xEC;			//PCA模块2捕获寄存器 LOW
//sfr CCAP2H = 0xFC;			//PCA模块2捕获寄存器 HIGH
//-----------------------------------------------------------------
//sfr PCA_PWM0 = 0xf2;			//PCA模块0的PWM寄存器
//sfr PCA_PWM1 = 0xf3;			//PCA模块1的PWM寄存器
//sfr PCA_PWM2 = 0xf4;			//PCA模块2的PWM寄存器
//-----------------------------------------------------------------
const u8 SEG_CODE[] =			//共阴数码管0～9段码表,最后一位为黑屏
 { 0x3F,0x06,0x5B,0x4F,0x66,0x6D,0x7D,0x07,0x7F,0x6F,0x00 };
volatile u8 Display_Buffer[] = {0,0,0,0};//分解后的待显示数位
volatile u8 cnt = 0;			//PCA计时溢出次数
volatile u32 count0 = 0;		//记录上次捕获值
volatile u32 count1 = 0;		//记录本次捕获值
volatile u32 length;			//存储信号的时间长度(count1-count0)
volatile u32 Freq[3];
//-----------------------------------------------------------------
// 延时函数(参数取值限于1~255)
//-----------------------------------------------------------------
void delay_ms(u8 ms) {
	u16 i;
	do{
		i = FOSC / 13000;
		while(--i);
	}while(--ms);
}
//-----------------------------------------------------------
// 数码管显示频率
//-----------------------------------------------------------
void Show_FRQ_ON_DSY() {
	u8 i;
	for (i = 0; i < 4; i++) {

	
	
	
	
	}
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	P0M1 = 0x00; P0M0 = 0x00;		//P0配置为准双向
	P1M1 = 0xFF; P1M0 = 0x00;		//P1配置为高阻输入
	P2M1 = 0x00; P2M0 = 0x00;		//P2配置为准双向
	//配置外设功能切换控制寄存器：P_SW1,置其CCP_S0=0 CCP_S1=0
	//切换CCP到：P1.2/ECI,P1.1/CCP0,P1.0/CCP1
	P_SW1 &= ~(CCP_S0 | CCP_S1);
	//初始化PCA控制寄存器CCON
	//其中CF置0,CR置0(停止运行),三个模块中断标志位CCF2/1/0:清0
	CCON = 0x00;
	CL = 0x00;			CH = 0x00;			//复位PCA 16位计数器
	CCAP1L = 0x00;	CCAP1H = 0x00;	//PCA模块1比较捕获寄存器清0
	//PCA模式设置为（00000001，即0x01）：其最高位CIDL置0：空闲模式继续,
	//置3~1位的CPS2/CPS1/CPS0=000，使用SYSclk/12作为时钟源（本例为12M/12=1M）,
	//置第0位ECF为1，使能计时溢出中断,中断触发时硬件置CF=1
	CMOD = 0x01;
	//配置PCA比较/捕获寄存器CCAPM1
	CCAPM1= 0x21;	//上升沿捕获,可测高电平开始的整个周期,且产生捕获中断
	//CCAPM1= 0x11;	//下降沿捕获,可测低电平开始的整个周期,且产生捕获中断
	//CCAPM1= 0x31;	//上升沿/下降沿捕获,可测高、低电平宽度,且产生捕获中断
	CR = 1;							//PCA定时器开始工作
	EA = 1;							//开总中断
	while (1) Show_FRQ_ON_DSY();	//数码管刷新显示频率
}
//-----------------------------------------------------------------
// PCA中断服务程序
//-----------------------------------------------------------------
void PCA_isr() interrupt 7 using 1 {
	u8 i; u32 Period;
	static u32 prePeriod  = 0;
	//////////P4 = cnt;
	/////////P6 = CH; P7 = CCAP1H;
	if (CF) {
		CF = 0;		//PCA计数溢出标志位软件清0
		cnt++;		//PCA计时溢出次数+1
	}
	if (CCF1) {				//CCP1输入捕获中断触发
		CCF1 = 0;				//CCP1捕获中断标志位软件清0
		count0 = count1;	//备份上一次的捕获值
		//获取当前捕获值
		count1 = (cnt<<16) + (CCAP1H<<8) + (CCAP1L);
		//上述代码行还可用下面4行代替
		//((u8 *)&count1)[3] = CCAP1L; //保存本次的捕获值
		//((u8 *)&count1)[2] = CCAP1H;
		//((u8 *)&count1)[1] = cnt;
		//((u8 *)&count1)[0] = 0;
		length = count1 - count0; //计算两次捕获的差值,即得到时间长度
		//分解频率数位并放入显示缓冲
		Period = 1000000L / length;
		if (Period == 0 || prePeriod == Period) return;
		prePeriod = Period;
		for (i = 3; i != 0xFF; i--) {
			Display_Buffer[i] = Period % 10;
			Period /= 10;
		}
	}
}