//------------------------ gsm_uart.c -----------------------------
// 名称: 串口控制函数
//-----------------------------------------------------------------
#include "STC15xxx.h"
#include "gsm_uart.h"
#include "string.h"
#include "delay.h"
//-----------------------------------------------------------------
// 本地变量声明
//-----------------------------------------------------------------
sbit LED1	= P2^4;						//发送指示灯
sbit LED2	= P2^5;						//超时指示灯
sbit LED3	= P2^6;						//接收指示灯
//-----------------------------------------------------------------
#define Buf_Size 200					//缓存长度
xdata u8 Uart_Buffer[Buf_Size];			//串口接收缓冲
volatile u8 Timeout_ReSendFlag = 0;	//T0延时启动计数器
volatile u8 TX1_Busy,TX2_Busy;			//串口发送忙标志
volatile u8 ResendTimer = 0, Front = 0, sCount = 0;
//-----------------------------------------------------------------
// 初始化串口1(9600bps@11.0592MHz) [本例仅用于串口调试显示]
//-----------------------------------------------------------------
void Uart1Init() {


}
//-----------------------------------------------------------------
// 初始化串口2(9600bps@11.0592MHz)  [本例用于GSM模块串口通信]
//-----------------------------------------------------------------
void Uart2Init() {


}
//-----------------------------------------------------------------
// 向串口1输出一个字符
//-----------------------------------------------------------------
void Uart1_PutChar(u8 c) {


}
//------------------------------------------------------------------
// 串口2输出字符串
//------------------------------------------------------------------
void Uart2_PutChar(u8 c) { 


}
//------------------------------------------------------------------
// 串口1输出字符串
//------------------------------------------------------------------
void Uart1_Putstr(char *s) { 


}
//------------------------------------------------------------------
// 串口2输出字符串
//------------------------------------------------------------------
void Uart2_Putstr(char *s) { 


}
//-----------------------------------------------------------------
// 清除缓存数据
//-----------------------------------------------------------------
void ClearUartBuffer() {


}
//-----------------------------------------------------------------
// UART1串口中断函数
//-----------------------------------------------------------------
void Serial_INT() interrupt 4 using 1 {


}
//-----------------------------------------------------------------
// UART2串口中断函数
//-----------------------------------------------------------------
void Uart2() interrupt 8 using 1  {


}
//-----------------------------------------------------------------
// 判断缓存中是否含有指定字符串
//-----------------------------------------------------------------
char* FindATCommand(u8 *comm_str) {


}
//-----------------------------------------------------------------
// 发送AT指令(b为命令,a为响应,WaitTime为重发等待时间,单位为50*20ms=1s)
//-----------------------------------------------------------------
u8 Send_ATCommand(u8 *b,u8 *a,u8 WaitTime, u8 retry_cnt) {
	static u8 cnt = 0;
	u8 OK = 0;					//初始时默认AT命令需重发
	u8 *c = b;					//保存命令串地址
	ClearUartBuffer();			//清除串口接收缓冲
	while(!OK) {
		if(!FindATCommand(a)) {	//应答串未找到则继续
			if(Timeout_ReSendFlag == 0) { //如果未到超时重发则正常发送
				ClearUartBuffer();	//清除串口接收缓冲
				b = c;				//将字符串地址给b
				//发送b所指向的命令字符串（各字符逐一发出）
				for (b; *b !='\0'; b++) Uart2_PutChar(*b);
				Uart2_Putstr("\x0D");		//发送回车符（编码）
				//或者：Uart2_Putstr("\r");	//发送回车符
				//Uart2_Putstr("\r\n");		//加\n（换行符）测试不通过
				ResendTimer = 0;			//超时重发计时变量归0
				sCount = WaitTime;			//置T1中断中的sCount（单位为秒）
				Timeout_ReSendFlag = 1;		//开始启动超时计时（T1中断控制）
				ET0 = 1; LED1 = ~LED1;		//使能定时中断且发送指示灯闪烁
				//3次重试失败后退出 
				if (++cnt > retry_cnt) {cnt = 0; break;}
			} 
			delay_ms(100);
		}		//如果分支从这里结束则将返回while继续循环 
		else {	//否则置OK等变量，循环将结束
			OK = 1; Timeout_ReSendFlag = 0; 
		}
	}
	LED1 = 1;								//发送指示灯熄灭
	ET0 = 0;								//禁止T0中断
	return OK;
}
//-----------------------------------------------------------------
// T0中断程序（中断周期：20ms）
//-----------------------------------------------------------------
void Timer0_ISR() interrupt 1 {


}
//-----------------------------------------------------------------
// 设置短信为PDU模式(本例暂未使用)
//-----------------------------------------------------------------
void Set_PDUMode() {
	Send_ATCommand("ATE0","OK",3,10);		//取消回显
	Send_ATCommand("AT+CMGF=0","OK",3,10);	//设置PDU模式
	Send_ATCommand("AT+CPMS=\"SM\",\"SM\",\"SM\"","OK",3,10);
}
//-----------------------------------------------------------------
// 发送PDU文本短信(本例暂未使用)
//-----------------------------------------------------------------
void Send_PDUSms(char *str) {
	Send_ATCommand("AT+CMGS=27",">",3,10); 
	Uart2_Putstr(str);						//发送短信内容
	Uart2_PutChar(0x1A);					//发送结束符
}