//-----------------------------------------------------------------
// 名称: 配置文件
//-----------------------------------------------------------------
#ifndef _CONFIG_H_
#define _CONFIG_H_
//#define FAT_FORMAT_FS		//文件系统格式化  此功能涉及ROM数据类型的读写，请先实现ROM数据的读写，并保证其稳定正确
#define FAT_FLUSH_FS			//刷新文件系统  如果没有使用RT_UPDATE_FSINFO，则在所有的文件操作完成之后，需要调用此函数

#define FAT_OPEN_FILE			//打开文件
#define FAT_CLOSE_FILE		//关闭文件 若无使用RT_UPDATE_FILESIZE，则进行文件数据写入删除等操作之后，需调用此函数，否则不调用也没关系
#define FAT_READDATA			//文件数据读取 
//#define FAT_READDATAX		//文件数据读取+重定向 此函数会将读取的每个字节送到处理函数，处理函数由使用者提供，请看宏Data_Redirect

#define FAT_CREATE_FILE		//创建文件
#define FAT_DELETE_FILE		//删除文件
#define FAT_WRITEDATA			//写入数据，写入数据均是从文件的末尾追加数据
#define FAT_MODIFY_DATA		//数据修改

#define FAT_CREATE_DIR		//创建目录，可以一次性创建多级深层目录
#define FAT_DELETE_DIR		//删除目录，目录下有子目录和文件，以及树状子目录结构，也可一并全部删除

//#define FAT_DUMP_DATA		//文件数据截断，从文件的某个位置之后的数据全部删除

//#define FAT_SEEK				//文件数据定位，使用者一般用不到，FAT已经把它封装到功能函数里

//#define USE_LFN						//开启FAT的长文件名功能，在长文件名下需要使用到较多的RAM资源，可支持的最长文件名长度可由MAX_LFN_LEN来定义
//#define USE_OEM_CHAR			//是否会使用OEM字符，即是否会在长名中出现中文字符
//#define MAX_LFN_LEN (100)	//如果一个文件有长名，则其对应的文件信息集合中的have_lfn=1，longname中记录的是
														//长名的unicode码（两个字节表示一个字符），这里定义的最大长名长度是unicode码长
														//MAX_LFN_LEN的值请根据实际目标系统的RAM资源来定义，防止RAM溢出 

//===================================================================================================================================

//#define TOV_CNT (200)					//存储设备扇区读写重试次数，如果次数超过此值，仍然失败，则会导致物理设备的IO错误
//#define IS_PIC //如果目标平台的CPU为PIC，则FAT针对其进行了专门处理，因为PIC中不能直接使用大数组
//#define USE_MULTISEC_R				//使用者是否提供多扇区连续读驱动
																//多扇区连续读驱动比单纯的单扇区读速度要快，如果不提供
																//多扇区连续读驱动，则FAT的数据操作性能将比较低
																//如果此宏被注释，则程序中默认使用单扇区读方式，执行效率
																//可能大打折扣

//#define USE_MULTISEC_W			//使用者是否提供多扇区连续写驱动
														//多扇区连续写驱动比单纯的单扇区写速度要快，如果不提供
															//多扇区连续写驱动，则FAT的数据操作性能将比较低
															//如果此宏被注释，则程序中单扇区写方式，执行效率可能大打折扣

//#define USE_MULTISEC_CLEAR	//使用者要提供多扇区连续清0函数
															//多扇区连续清0，将应用于格式化中，会使格式化速度提升
															//如果此宏被注释，则程序中默认使用单个扇区逐个清0的方式
															//执行效率可能会大打折扣

#define RT_UPDATE_FSINFO			//实时更新FSINFO扇区，主要是更新剩余簇数，下一空簇参考值更新没有意义，因为它本身就不保证一定正确
															//很多操作系统中获取可用的空簇，并不以它作为依据，而是直接扫描整个FAT表。剩余簇数是可以使用的，
															//用于计算磁盘剩余容量，如果它的值为0，则说明磁盘已满，在FAT中对其进行了维护
#define RT_UPDATE_FILESIZE		//实时更新文件信息
															//以下两个用于“实用更新”的宏如果被注释掉，则在文件操作结束后，一定要调用FAT_Close_File，否则
															//磁盘相关信息将不会被更新，导致虽然向文件写入了数据，但我们仍然看不到等问题。

//=================================================================================================================================
//CCCB，压缩簇链缓冲，是FAT中所使用簇链缓冲算法，它可以极大的提供数据写入的速度
#define RT_UPDATE_CLUSTER_CHAIN //是否实时更新FAT簇链，不实时更新，则使用CCCB簇链缓冲，可以加快数据写入速度

//#define USE_ALONE_CCCB		//选择是否使用独立簇链缓冲，在RAM资源比较充裕的情况下，这种工作方式下将给每个文件开辟出一个独立的簇链缓冲
														//与之相对的是共享簇链缓冲（shared CCCB），多个文件同时共享一个簇链缓冲，会涉及到簇链缓冲的争抢，效率较alone CCCB低。
														//在频繁交替对多个文件进行小数据量写入时，共享簇链缓冲将起不到什么作用
#define CCCB_LEN (8)				//簇链缓冲的长度，必须为偶数，且不小于4

//===============================================
//EXB，交换缓冲区，是FAT中针对于不足整扇区数据的拼接处理的专用缓冲区，可以较大程度上改进因数据拼接导致的效率低下
//#define USE_EXCHANGE_BUFFER
#define USE_ALONE_EXB //每个文件都有它单独的交换缓冲区，否则使用共享交换缓冲区
//===============================================

//#define Data_Redirect VS_Send_Dat //数据重定向函数名定义 

#endif