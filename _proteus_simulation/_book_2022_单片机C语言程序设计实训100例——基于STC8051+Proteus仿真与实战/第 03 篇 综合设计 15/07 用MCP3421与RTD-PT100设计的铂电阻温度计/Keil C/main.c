//------------------------- main.c --------------------------------
//  名称: 用MCP3421与RTD-PT100设计的铂电阻温度计
//-----------------------------------------------------------------
//  说明: 本例MCP3421工作于18位精度模式,程序运行时,根据模/数转换结果
//		  得到阻值,然后根据Callendar-Van Dusen温度/电阻关系式求解方程,
//		  得出-200℃ ~ 850℃范围内的温度值,显示在128*64液晶屏上.
// 
//-----------------------------------------------------------------
#include "STC15xxx.h"
#include <intrins.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#define MAIN_Fosc 12000000L	//时钟频率定义
#define u8	unsigned char
#define u16	unsigned int
#define u32	unsigned long
long AD_Result;				//模数转换结果
//ITS-90/IEC751(α = 0.0038505),PT100标准系数
#define coeffA ( 3.9083/1000.0)
#define coeffB (-5.775/10000000.0)
#define coeffC (-4.183/1000000000000.0)
#define R0 100.0  			//PT100在0℃的阻值
#define Gain 4				//增益配置
u8 d[4];					//MCP3421 A/D转换器结果字节暂存数组
float Res,Temp;				//PT100电阻值,当前温度
char disp_Buff[10];			//显示缓冲
//函数声明
extern void IIC_Init();
extern void Write_MCP3421(u8 d);
extern void Read_MCP3421(u8 *d);
extern void Display_A_Char_8x16(u8 P,u8 L,u8 *M);
extern void LCD_Initialize();
extern void Display_A_WORD_String(u8 P,u8 L,u8 C,u8 *M);
//待显示汉字点阵(在ZIMO软件中取模时,设宋体小四号,纵向取模,字节倒序)
code u8 DIGIT_Dot_Matrix[] = {//0~9,.,-及空格的点阵(8*16)
0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0
0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1
0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2
0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3
0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4
0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5
0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6
0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7
0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8
0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//.
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//-
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//SP
};
code u8 WORD_Dot_Matrix[] = {//铂电阻温度计,实心右三角形符号,℃的点阵(16*16)
/*--  文字:  铂  --*/
0x40,0x30,0x2C,0xEB,0x28,0x28,0x08,0x00,0xF8,0x88,0x8C,0x8B,0x88,0x88,0xF8,0x00,
0x01,0x01,0x01,0x7F,0x21,0x11,0x09,0x00,0x7F,0x20,0x20,0x20,0x20,0x20,0x7F,0x00,
/*--  文字:  电  --*/
0x00,0x00,0xF8,0x48,0x48,0x48,0x48,0xFF,0x48,0x48,0x48,0x48,0xF8,0x00,0x00,0x00,
0x00,0x00,0x0F,0x04,0x04,0x04,0x04,0x3F,0x44,0x44,0x44,0x44,0x4F,0x40,0x70,0x00,
/*--  文字:  阻  --*/
0x00,0xFF,0x11,0x29,0xC7,0x01,0xFE,0x22,0x22,0x22,0x22,0x22,0xFE,0x00,0x00,0x00,
0x00,0xFF,0x02,0x04,0x43,0x40,0x7F,0x42,0x42,0x42,0x42,0x42,0x7F,0x40,0x40,0x00,
/*--  文字:  温  --*/
0x10,0x21,0x86,0x70,0x00,0x7E,0x4A,0x4A,0x4A,0x4A,0x4A,0x7E,0x00,0x00,0x00,0x00,
0x02,0xFE,0x01,0x40,0x7F,0x41,0x41,0x7F,0x41,0x41,0x7F,0x41,0x41,0x7F,0x40,0x00,
/*--  文字:  度  --*/
0x00,0x00,0xFC,0x04,0x24,0x24,0xFC,0xA5,0xA6,0xA4,0xFC,0x24,0x24,0x24,0x04,0x00,
0x80,0x60,0x1F,0x80,0x80,0x42,0x46,0x2A,0x12,0x12,0x2A,0x26,0x42,0xC0,0x40,0x00,
/*--  文字:  计  --*/
0x20,0x21,0x2E,0xE4,0x00,0x00,0x20,0x20,0x20,0x20,0xFF,0x20,0x20,0x20,0x20,0x00,
0x00,0x00,0x00,0x7F,0x20,0x10,0x08,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,
/*--  文字:  右三角形符号  --*/
0x00,0xFE,0xFE,0xFC,0xFC,0xF8,0xF8,0xF0,0xF0,0xF0,0xE0,0xE0,0xC0,0xC0,0x80,0x80,
0x00,0x3F,0x3F,0x1F,0x1F,0x0F,0x0F,0x07,0x07,0x07,0x03,0x03,0x01,0x01,0x00,0x00,
/*--  文字:  ℃  --*/
0x00,0x02,0x05,0xE2,0x18,0x04,0x02,0x02,0x02,0x02,0x02,0x02,0x04,0x1E,0x00,0x00,
0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x40,0x40,0x40,0x40,0x40,0x20,0x18,0x00,0x00
};
//-----------------------------------------------------------------
// 延时函数(参数取值限于1~255)
//-----------------------------------------------------------------
void delay_ms(u8 ms) {
	u16 i;
	do{
		i = MAIN_Fosc / 13000;
		while(--i);
	}while(--ms);
}
//-----------------------------------------------------------------
// 根据从MCP3421所读取的三字节模数转换结果计算得到电阻值
// 模数转换精度:18位 增益:4 恒流源:1mA
//-----------------------------------------------------------------
void GetRes() {


}
//-----------------------------------------------------------------
// 正温度直接使用解析法求根
//-----------------------------------------------------------------
void Calc_2_equation(float r) {


}
//-----------------------------------------------------------------
// 用二分迭代法求解Callendar-Van Dusen方程,根据阻值求取温度值
//-----------------------------------------------------------------
//void Calc_Temp_Bisection() {
//	float x, a = 0, b = -200, t1,t2,t3,t4, Fa,Fx;
//	do
//	{	x = (a+b)/2; 
//		t1 = a; t2 = t1 * a; t3 = t2 * a; t4 = t3 * a;
//		Fa = t4 - 100*t3 +coeffB/coeffC*t2 +coeffA/coeffC*t1
//			+ 1/coeffC*(1-Res/R0);
//		t1 = x; t2 = t1 * x; t3 = t2 * x; t4 = t3 * x;
//		Fx = t4 - 100*t3 +coeffB/coeffC*t2 +coeffA/coeffC*t1
//			+ 1/coeffC*(1-Res/R0);
//		if (Fa * Fx < 0) b = x; else a = x;
//	} while (fabs(b-a) > 0.01);
//	Temp = a;
//} 
//-----------------------------------------------------------------
// 用牛顿法求解Callendar-Van Dusen方程,根据阻值求取温度值
//-----------------------------------------------------------------
void Calc_Temp_Newton() {
	float x0 = 0, x1 = 0, t1,t2,t3,t4, Ft,Ftt;
	do	{
		x0 = x1; 
		t1 = x0; t2 = t1 * x0; t3 = t2 * x0; t4 = t3 * x0;
		Ft = t4 - 100*t3 + coeffB/coeffC*t2 + coeffA/coeffC*t1 
			+ 1/coeffC*(1-Res/R0);
		Ftt = 4*t3 - 300*t2 + 2*coeffB/coeffC*t1 
			+ coeffA/coeffC;
		x1 = x0 - Ft/Ftt;
	} while (fabs(x1-x0) > 0.01); 
	Temp = x0;
} 
//-----------------------------------------------------------------
// 显示温度
//-----------------------------------------------------------------
void disp_value() {
	char i , c, len = strlen(disp_Buff);
	memset(disp_Buff + len,' ',7 - len);	//不足部分用空格填充
	//输出数字串(含小数点,符号位及空格)到液晶屏显示
	for (i = 0; i < 7; i++) {
		//将数字字符0~9及小数点"."/"-"转换为DIGIT_Dot_Matrix
		//数组中的对应索引值
		 c = disp_Buff[i]; 
		 if (c == '.') c = 10; else
		 if (c == '-') c = 11; else
		 if (c == ' ') c = 12; else c -= '0';
		 //液晶显示
		 Display_A_Char_8x16(5, 40 + 8 * i, DIGIT_Dot_Matrix + c * 16);
	}
}
//-----------------------------------------------------------------
// 主程序
//-----------------------------------------------------------------
void main() {
	P0M1 = 0; P0M0 = 0;			//配置为准双向口
	P2M1 = 0; P2M0 = 0;
	P3M1 = 0; P3M0 = 0;
	LCD_Initialize();			//初始化LCD
	//从第2页开始(即LCD的第16行),左边距16,显示"铂电阻温度计"
	Display_A_WORD_String(2, 16,  6, WORD_Dot_Matrix);
	//从第5页开始(即LCD的第40行),左边距16,显示右三角形
	Display_A_WORD_String(5, 16,  1, WORD_Dot_Matrix + 32 * 6);
	//从第5页开始(即LCD的第40行),左边距96,显示"℃"
	Display_A_WORD_String(5, 12*8,1, WORD_Dot_Matrix + 32 * 7);
	delay_ms(10);
	while (1) {
		Write_MCP3421(0x1E);	//设置18位精度(3.75SPS)及PGA增益Gain=4;
		delay_ms(5); 			//延时10ms
		Read_MCP3421(d);		//从MCP3421读取原始数据
		GetRes();				//由A/D值转换得到阻值
		if (Res >= 100)			//由PT100阻值计算温度值
		  Calc_2_equation(Res);	//(1)正温度通过公式求根
		else Calc_Temp_Newton();//(2)负温度通过牛顿法(或二分法)求根
		sprintf(disp_Buff,"%6.2f",Temp);//温度数据转换为字符串
		disp_value();			//LCD刷新显示
	}
}