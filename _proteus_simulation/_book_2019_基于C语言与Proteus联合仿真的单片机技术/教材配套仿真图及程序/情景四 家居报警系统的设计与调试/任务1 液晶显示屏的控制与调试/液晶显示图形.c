
//***************************************************************
//*********************显示轻工的LOGO图标（居中显示）****************************************
//************************************** ********************


#include <reg51.h>


#define LCDP  P1 	//	定义LCM 资料汇流排接至P1

sbit RS	=	P2^4;	//	暂存器选择位元(0:指令,1:资料)
sbit RW	=	P2^5;	//	设定读写位元 (0:写入,1:读取)
sbit E	=	P2^6;	//	致能位元 (0:禁能,1:致能)
sbit BF	=	P1^7;	//	忙碌检查位元(0:不忙,1:忙碌)数据线的最高位//液晶实物中没有BF这个脚的，实物不用接线的


char code tuxing[]={0x00,0x00,0x00,0x00,0x00,0xFC,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0x00,0x00,
0x00,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x07,0xFF,0xC0,0x00,
0x00,0x00,0x10,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,0x20,0x00,0x1F,0xFF,0xE0,0x00,
0x00,0x00,0xE0,0x00,0x3F,0xFF,0xF0,0x00,0x00,0x01,0xC0,0x00,0x3F,0xFF,0xF0,0x00,
0x00,0x03,0x80,0x00,0x3F,0xFF,0xF0,0x00,0x00,0x07,0x00,0x00,0x3F,0xFF,0xF0,0x00,
0x00,0x0E,0x00,0x00,0x3F,0xFF,0xF0,0x00,0x00,0x1C,0x00,0x00,0x1F,0xFF,0xE0,0x00,
0x00,0x38,0x00,0x00,0x1F,0xFF,0xE0,0x00,0x00,0x38,0x00,0x00,0x1F,0xFF,0xE0,0x00,
0x00,0x70,0x00,0x00,0x1F,0xFF,0xC0,0x00,0x01,0xF0,0x00,0x00,0x0F,0xFF,0xC0,0x00,
0x01,0xF0,0x00,0x00,0x0F,0xFF,0x80,0x00,0x03,0xE0,0x00,0x00,0x07,0xFF,0x00,0x00,
0x07,0xE0,0x00,0x00,0x01,0xFE,0x1F,0x80,0x07,0xE0,0x00,0x00,0x00,0x78,0x1F,0x80,
0x07,0xC0,0x00,0x00,0x00,0x00,0xFF,0xC0,0x0F,0xC0,0x00,0x00,0x00,0x03,0xFF,0xC0,
0x0F,0xC0,0x00,0x00,0x00,0x3F,0xFF,0xC0,0x1F,0xC0,0x00,0x00,0x07,0xFF,0xFF,0xE0,
0x1F,0xC0,0x00,0x00,0x07,0xFF,0xFF,0xE0,0x1F,0xC0,0x00,0x00,0x3F,0xFF,0xFF,0xE0,
0x1F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x1F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,
0x3F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x3F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,
0x3F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x3F,0xC0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,
0x3F,0xE0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,0x3F,0xE0,0x00,0x00,0x7F,0xFF,0xFF,0xF0,
0x3F,0xE0,0x00,0x00,0xFF,0xC7,0xFF,0xF0,0x3F,0xF0,0x00,0x00,0xFE,0x07,0xFF,0xF0,
0x3F,0xF0,0x00,0x01,0xF0,0x07,0xFF,0xF0,0x1F,0xF0,0x00,0x03,0x80,0x07,0xFF,0xE0,
0x1F,0xF0,0x00,0x03,0x80,0x07,0xFF,0xE0,0x1F,0xFC,0x00,0x00,0x00,0x07,0xFF,0xE0,
0x1F,0xFE,0x00,0x00,0x00,0x0F,0xFF,0xE0,0x0F,0xFF,0x00,0x00,0x00,0x0F,0xFF,0xC0,
0x0F,0xFF,0x80,0x00,0x00,0x0F,0xFF,0xC0,0x0F,0xFF,0x80,0x00,0x00,0x0F,0xFF,0xC0,
0x07,0xFF,0xF0,0x00,0x01,0x3F,0xFF,0x80,0x07,0xFF,0xFE,0x00,0x02,0x3F,0xFF,0x80,
0x03,0xFF,0xFE,0x00,0x06,0x3F,0xFF,0x80,0x03,0xFF,0xFF,0xE0,0x3C,0x7F,0xFF,0x00,
0x01,0xFF,0xFF,0xFF,0xFC,0xFF,0xFE,0x00,0x00,0xFF,0xFF,0xFF,0xF9,0xFF,0xFE,0x00,
0x00,0x7F,0xFF,0xFF,0xF1,0xFF,0xFC,0x00,0x00,0x3F,0xFF,0xFF,0xE7,0xFF,0xF8,0x00,
0x00,0x1F,0xFF,0xFF,0x8F,0xFF,0xF0,0x00,0x00,0x0F,0xFF,0xFE,0x1F,0xFF,0xE0,0x00,
0x00,0x07,0xFF,0xFC,0x3F,0xFF,0xC0,0x00,0x00,0x01,0xFF,0xF0,0xFF,0xFF,0x80,0x00,
0x00,0x00,0x07,0xC3,0xFF,0xFF,0x00,0x00,0x00,0x00,0x70,0x0F,0xFF,0xFE,0x00,0x00,
0x00,0x00,0x1F,0xFF,0xFF,0xF8,0x00,0x00,0x00,0x00,0x07,0xFF,0xFF,0xE0,0x00,0x00,
0x00,0x00,0x01,0xFF,0xFF,0x80,0x00,0x00,0x00,0x00,0x00,0x7F,0xFE,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//D:\其它\学校标识点阵\64.64.BMP0



void init_LCM(void);	//	初始设定函数 
void write_inst(char);	//	写入指令函数 
void write_char(char);	//	写入字元资料函数 
void check_BF(void);	//	检查忙碌函数 
void delay1ms(int);		//	延迟函数
void clean(void);		//	清除图形子程序

 	
// ============ 主程序 ===========================
main()
{	char i;							// 声明变量
 	char y=0;						//列地址变量
	char x=0;						//页变量
	init_LCM();						// 初始设定
    clean(); 						//调用清除图形子程序
	while(1)						// 无尽循环 	
	{ for(y=0;y<32;y++)				//上半屏的1－32点阵行
	  {  for(x=2;x<6;x++)			//第2－6页
	     {write_inst(0x80+y);			//第y点阵行
	 	  write_inst(0x80+x);			//第x页
		  write_char(tuxing[2*(x-2)+8*y]);	//2x和2x+1是相邻的两个数据，加8y是隔开y个点阵行
		  write_char(tuxing[2*(x-2)+1+8*y]);//因为x是2－6，所以要减2，
	      }
	   }
		  
	 for(y=0;y<32;y++)				//下半屏的1－32点阵行
	  {  for(x=10;x<14;x++)			//第10－14页
	     {write_inst(0x80+y);			//第y点阵行
	 	  write_inst(0x80+x);			//第x页
		  write_char(tuxing[2*(x-10)+8*y+8*32]);	//2x和2x+1是相邻的两个数据，加8y是隔开y个点阵行
		  write_char(tuxing[2*(x-10)+1+8*y+8*32]);//因为x是10－14，所以要减10，后半屏，再加上一半数据量8乘32
	      }
	  }
		write_inst(0x36);			//开绘图

		while(1);
 
		
		 
	}								// while结束 
}									// 主程序main()结束




 
//====初始设定函数(8位元传输模式)===================
void init_LCM(void)
{	write_inst(0x34);	// 设定扩展指令集,关绘图 
	 
}
//==== 写入指令函数 ================================
void write_inst(char inst)
{	check_BF();				// 检查是否忙碌 
	LCDP = inst;			// LCM读入MPU指令 
	RS = 0; RW = 0; E = 1;	// 写入指令至LCM
	check_BF();				// 检查是否忙碌 
}							// write_inst()函数结束 
//==== 写入字元资料函数 ============================
void write_char(char chardata)
{	check_BF();				// 检查是否忙碌 
	LCDP = chardata;		// LCM读入字元 
	RS = 1; RW = 0 ;E = 1;	// 写入资料至LCM
	check_BF();				// 检查是否忙碌 
}							// write_char()函数结束	
//====检查忙碌函数================================
void check_BF(void)
{	E=0;					// 禁止读写动作 
	do						// do-while循环开始 
	{ 	BF=1;				// 设定BF为输入 
  	RS = 0; RW = 1;E = 1;	// 读取BF及AC
	}while(BF == 1);		// 忙碌继续等 
}							//	check_BF()函数结束

//====清除图形子程序===================
void clean(void)
{
unsigned char j,k;
  write_inst(0x34);      //在写GDRAM的地址之前一定要打开扩充指令集
                           //否则地址写不进去！！
  for(j=0;j<32;j++)
  {
   
    write_inst(0x80+j);    //写Y 坐标
    write_inst(0x80);        //写X 坐标
  
    for(k=0;k<32;k++) //写一整行数据
    {
     write_char(0x00);
    }
  }  


}


 
//==== 延迟函数 ================================
void delay1ms(int x)
{	int i,j;				// 声明变量 
	for (i=0;i<x;i++)		// 执行x次,延迟X*1ms
		for (j=0;j<120;j++);// 执行120次,延迟1ms
}							// delay1ms()函数结束 



//***************************************************************