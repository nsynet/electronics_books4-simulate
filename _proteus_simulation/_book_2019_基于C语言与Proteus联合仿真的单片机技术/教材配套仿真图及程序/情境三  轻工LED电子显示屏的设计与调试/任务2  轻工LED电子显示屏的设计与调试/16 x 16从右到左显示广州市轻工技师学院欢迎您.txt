// 16*16 LED点阵从右到左滚动显示汉字“广州市轻工技师学院欢迎您”
#include<reg51.h>
#include<intrins.h>	 //要调用到1us子函数_nop_( )
#define saomiao P1	//接行扫描信号A,B,C,D。再接138芯片后接三极管反相驱动。最后是高电平驱动点阵。
sbit DS=P3^0;		     //595芯片的数据输入端。
sbit CLK=P3^1;		//595写信号，上升沿有效。
sbit ST=P3^2;		     //595并行输出信号，上升沿有效。
sbit OE=P3^3;		     //138使能信号，低电平有效。
delay(int);
void WR_595(unsigned char);          //定义写595函数
void OUT_595(void);                  //定义输出595函数
int repeat=5;                        //每个汉字停留时间，延时
unsigned char code seg[]=			//*******注意，因为要移位，所以要改为无符号数
{
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//一开始，加多一个字的空码，让字滚动时完全从右边出来
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//

 0x7F,0xFF,0xFF,0xFE,0xFF,0xFE,0x03,0xC0,0xFB,0xFF,0xFB,0xFF,0xFB,0xFF,0xFB,0xFF,
0xFB,0xFF,0xFB,0xFF,0xFB,0xFF,0xFB,0xFF,0xFB,0xFF,0xFD,0xFF,0xFD,0xFF,0xFE,0xFF,//"广",0

0xF7,0xDF,0xF7,0xDE,0xF7,0xDE,0xF7,0xDE,0xF7,0xDE,0xD5,0xDA,0xB5,0xD6,0xB5,0xD6,
0xF6,0xDE,0xF7,0xDE,0xF7,0xDE,0xF7,0xDE,0xFB,0xDE,0xFB,0xDE,0xFD,0xDF,0xFE,0xDF,//"州",1

0xBF,0xFF,0x7F,0xFF,0xFF,0xFF,0x01,0xC0,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x03,0xE0,
0x7B,0xEF,0x7B,0xEF,0x7B,0xEF,0x7B,0xEF,0x7B,0xEB,0x7B,0xF7,0x7F,0xFF,0x7F,0xFF,//"市",2

0xFB,0xFF,0x7B,0xC0,0xFB,0xEF,0xC0,0xF7,0xFD,0xF3,0xF5,0xED,0xF6,0xDE,0x00,0xBF,
0xF7,0xFF,0x77,0xC0,0xC7,0xFB,0xF0,0xFB,0xF5,0xFB,0xF7,0xFB,0x37,0x80,0xF7,0xFF,//"轻",3

0xFF,0xFF,0xFF,0xFF,0x01,0xC0,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,
0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x80,0xFF,0xFF,0xFF,0xFF,//"工",4

0xF7,0xFB,0xF7,0xFB,0xF7,0xFB,0x37,0x80,0xC0,0xFB,0xF7,0xFB,0xF7,0xFB,0x57,0xC0,
0xE7,0xDE,0xF3,0xEE,0xF4,0xED,0xF7,0xF5,0xF7,0xFB,0xF7,0xF5,0x75,0xEE,0x9B,0x9F,//"技",5

0xEF,0xFF,0x2F,0x80,0xED,0xFB,0xED,0xFB,0xED,0xFB,0x6D,0xC0,0x6D,0xDB,0x6D,0xDB,
0x6D,0xDB,0x6D,0xDB,0x6D,0xDB,0x6F,0xD3,0x77,0xEB,0xF7,0xFB,0xFB,0xFB,0xFD,0xFB,//"师",6

0xBB,0xEF,0x77,0xEF,0x77,0xF7,0xFF,0xFB,0x01,0x80,0xFD,0xBF,0xFE,0xDF,0x07,0xF8,
0xFF,0xFD,0x7F,0xFE,0x00,0x80,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x5F,0xFF,0xBF,0xFF,//"学",7

0xFF,0xFD,0xE1,0xFB,0x2D,0x80,0xB5,0xBF,0xD5,0xDF,0x79,0xE0,0xF5,0xFF,0xED,0xFF,
0x2D,0x80,0xED,0xF6,0xE9,0xF6,0xF5,0xF6,0x7D,0xB7,0x7D,0xB7,0xBD,0x8F,0xDD,0xFF,//"院",8

0xFF,0xFE,0xFF,0xFE,0xC0,0xFE,0xDF,0xC0,0x5F,0xDF,0x6D,0xEF,0xAB,0xFD,0xD7,0xFD,
0xF7,0xFD,0xEB,0xFA,0xDB,0xFA,0x5D,0xF7,0x7E,0xF7,0xBF,0xEF,0xDF,0xDF,0xEF,0xBF,//"欢",9

0xFF,0xFF,0xFB,0xFE,0x37,0xC3,0xB7,0xDB,0xBF,0xDB,0xBF,0xDB,0xB0,0xDB,0xB7,0xDB,
0xB7,0xDB,0xB7,0xD2,0x37,0xEB,0xB7,0xFB,0xF7,0xFB,0xEB,0xFB,0x1D,0x80,0xFF,0xFF//"迎",10

0x6F,0xFF,0x6F,0xFF,0x77,0xC0,0xB3,0xDF,0xD5,0xED,0x66,0xF5,0x77,0xED,0xB7,0xDD,
0xD7,0xDD,0x77,0xFD,0xF7,0xFE,0xBF,0xFF,0x75,0xDF,0x75,0xB7,0xF6,0xB7,0x0F,0xF0，//"您",11

 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
//结束时，加多一个字的空码，让字滚动时完全从左边出来
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff};//
//===================================主程序===============================================
main()
{
int i;//
int m;//
int n;//移位的次数
int j;//第几个文字
unsigned char a,b,c,d,b1,c1,d1;// 中间变量，存移位的结果，注意，一定要无符号数，因为要移位
OE=0; //138使能信号，低电平有效。可以不用接单片机，直接接地。
	while(1)
	{
		for(m=0;m<repeat;m++)
		{
			 for(i=0;i<16;i++)
			{
			a=seg[2*i+32*j]; //取第一个字的第0个码
			b=seg[2*i+1+32*j];//取第一个字的第1个码
			c=seg[32+2*i+32*j];//取第二个字的第0个码
			d=seg[32+2*i+1+32*j];//取第二个字的第1个码
			saomiao=i;
		
		if(n<8)//因为每个字移16次，n计数16次，把它分为前8次和后8次
		{
		b1=b<<(8-n);	// b要左移n位给a，把b要移的位全部移动到右边先，再跟a来或。
		a=a>>n|b1;	// a跟刚才的结果相或
		c1=c<<(8-n);	// c要左移n位给b，把c要移的位全部移动到右边先，再跟b来或。
		b1=b>>n|c1;	// b跟刚才的结果相或
		WR_595(b1);
		WR_595(a);
		OUT_595();
			}


		if(n>=8) //把它分为前8次和后8次,8次要处理一下，移位次数减去8
		{
	c1=c<<(8-(n-8));//c要左移n位给b，把c要移的位全部移动到右边先，再跟b来或。
	b=b>>(n-8)|c1;	//b跟刚才的结果相或
	d1=d<<(8-(n-8));//d要左移n位给c，把d要移的位全部移动到右边先，再跟c来或。
	c1=c>>(n-8)|d1;//c跟刚才的结果相或
	WR_595(c1);
	WR_595(b);
	OUT_595();
			}
delay(2);
	WR_595(0xff);//清重影
	WR_595(0xff);
	OUT_595();
		}		
	  }	
		n=n+1;				          //移1位
		if(n==16){n=0;j=j+1;}	     //移到16次时，表示一个字移完了，J加1表示下一个字
		if(j==13){j=0;delay(30000);}  //字的总个数
	}

}
//==================================延时程序======================================
delay(int x)
{
int i,j;
	for(i=0;i<x;i++)
	for(j=0;j<120;j++);
}
//========================写595函数，把数据一位一位送到595===================================
void WR_595(unsigned char a)       
{unsigned char b,da;
 for(b=0;b<8;b++)
    {da=a&0x80; 
	if(da==0) DS=0;                 //如果da为0，把0送595
	if(da!=0) DS=1;                 //如果da为1，把1送595
     a<<=1;                         //数据左移，为移第2位作准备
     CLK=0;                         //先清0
     _nop_();
	 _nop_();
	 _nop_();                     
     CLK=1;                          //再为1，即产生上升沿，开始移1位
     }
}
//====================================输出595函数==========================================
void OUT_595()                       
{	ST=0;                            //先清0
	_nop_();
	_nop_();
	_nop_();                          
 	ST=1;                            //再为1，即产生上升沿，开始并行输出16位
}
