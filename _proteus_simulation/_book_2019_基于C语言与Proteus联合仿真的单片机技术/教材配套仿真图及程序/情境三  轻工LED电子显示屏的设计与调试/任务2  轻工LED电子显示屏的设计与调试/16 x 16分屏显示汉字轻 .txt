//16*16 LED点阵分屏显示汉字“走进轻工迈向成功”
//分屏显示汉字“走进轻工迈向成功”，可以利用通过一维数组把这8个汉字的数据码存放起来。每显示完一个汉字延时0.5s，即可让点阵分屏显示“走进轻工迈向成功”。具体程序如下：
-------------------------------------------------------------------------------------------
#include<reg51.h>
#include<intrins.h>    //要调用到1us子函数 _nop_()
#define saomiao P1	//接行扫描信号A,B,C,D，再接74LS138芯片后接74LS04反相放大，,最后是高电平驱动点阵
sbit DS=P3^0;		//74HC595芯片的数据输入端。
sbit CLK=P3^1;		//74HC595芯片的写信号，上升沿有效。
sbit ST=P3^2;		//74HC595芯片的并行输出信号，上升沿有效。
sbit OE=P3^3;		//138使能信号，低电平有效，也可以不用接单片机，直接接地。
delay(int);
void WR_74HC595(unsigned char);           //定义写74HC595函数
void OUT_74HC595(void);                  //定义输出74HC595函数
int repeat=30;                           //每个汉字停留时间，延时
char code seg[ ]={
{0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x03,0xE0,0x7F,0xFF,0x7F,0xFF,0x00,0x80,0x7F,0xFF,
0x7F,0xFF,0x77,0xFF,0x77,0xE0,0x77,0xFF,0x77,0xFF,0x6B,0xFF,0x1D,0x80,0xFE,0xFF},    //"走",0
{0xFF,0xF6,0xFB,0xF6,0xF7,0xF6,0x37,0xC0,0xFF,0xF6,0xFF,0xF6,0xF0,0xF6,0x17,0x80,
0xF7,0xF6,0xF7,0xF6,0x77,0xF7,0x77,0xF7,0xB7,0xF7,0xEB,0xFF,0x1D,0x80,0xFF,0xFF},    //"进",1
{0xFB,0xFF,0x7B,0xC0,0xFB,0xEF,0xC0,0xF7,0xFD,0xF3,0xF5,0xED,0xF6,0xDE,0x00,0xBF,
0xF7,0xFF,0x77,0xC0,0xC7,0xFB,0xF0,0xFB,0xF5,0xFB,0xF7,0xFB,0x37,0x80,0xF7,0xFF},    //"轻",2
{0xFF,0xFF,0xFF,0xFF,0x01,0xC0,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,
0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x7F,0xFF,0x00,0x80,0xFF,0xFF,0xFF,0xFF},          //"工",3
{0xFF,0xFF,0xFB,0xFF,0x17,0x80,0xF7,0xFE,0xFF,0xFE,0xFF,0xC0,0xF0,0xDE,0xF7,0xDE,
0xF7,0xDE,0x77,0xDF,0x77,0xDF,0xB7,0xEB,0xD7,0xF7,0xEB,0xFF,0x1D,0x80,0xFF,0xFF},       //"迈",4
{0xBF,0xFF,0xDF,0xFF,0xEF,0xFF,0x01,0xC0,0xFD,0xDF,0xFD,0xDF,0x1D,0xDC,0xDD,0xDD,
0xDD,0xDD,0xDD,0xDD,0xDD,0xDD,0x1D,0xDC,0xDD,0xDD,0xFD,0xDF,0xFD,0xD7,0xFD,0xEF},   //"向",5
{0xFF,0xF5,0xFF,0xED,0xFF,0xFD,0x03,0x80,0xFB,0xFD,0xFB,0xFD,0xFB,0xDD,0x83,0xDD,
0xBB,0xDD,0xBB,0xEB,0xBB,0xEB,0xBB,0xB7,0xAB,0xB3,0xDD,0xAD,0xFD,0x9E,0x7E,0xBF},     //"成",6
{0xFF,0xFD,0xFF,0xFD,0xFF,0xFD,0x80,0xFD,0x77,0xC0,0xF7,0xDD,0xF7,0xDD,0xF7,0xDD,0xF7,
0xDD,0xF7,0xDE,0xF7,0xDE,0x87,0xDE,0x70,0xDF,0x7D,0xDF,0xBF,0xEB,0xDF,0xF7}             //"功",7
};	  
//===============================主函数==============================================
main()
{
int i;
int m;
int j;
OE=0;  //138使能信号，低电平有效，可以不用接单片机，直接接地。
	while(1)
	{
		for(m=0;m<repeat;m++)
		{  for(i=0;i<16;i++)
		  {  saomiao=i;
		    WR_595(seg[2*i+1+32*j]);
		    WR_595(seg[2*i+32*j]);
		    OUT_595();
	  	delay(2);
	    WR_595(0xff);//清重影
		  WR_595(0xff);
		  OUT_595();
		  }
	}
j++;
if(j==8) j=0;
}
}
//==============================延时函数=====================================================
delay(int x)
{
int i,j;
	for(i=0;i<x;i++)
	for(j=0;j<120;j++);
}
//==============================写74HC595函数，把数据一位一位送到74HC595========================
void WR_74HC595(unsigned char a)          
{  unsigned char b,da;
   for(b=0;b<8;b++)
 {da=a&0x80;      //数据与10000000相与，保留最高位，如果最高位为1，da为10000000，如果最高位为0，da为00000000.
	if(da==0)   DS=0;                 //如果da为0，把0送74HC595
	if(da!=0)   DS=1;                 //如果da为1，把1送74HC595
     a<<=1;                              //数据左移，为移第2位作准备
     CLK=0;                             //先清0
     _nop_( );
 _nop_( );
 _nop_( );                     
     CLK=1;                             //再为1，即产生上升沿，开始移1位
     }
}
//==========================输出74HC595函数，数据并行输出至16*16 LED点阵的列输入端口===============
void OUT_74HC595()                          
{	ST=0;                           //先清0
	_nop_( );
	_nop_( );
	_nop_( );                          
 	ST=1;                           //再为1，即产生上升沿，开始并行输出16位
}